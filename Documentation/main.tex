\documentclass[12pt]{article}
\usepackage{graphicx} 
\usepackage{caption}
\usepackage{float}
\usepackage{amsmath}
\usepackage{subcaption}

\captionsetup{justification=centering}

\usepackage[utf8]{inputenc}
\usepackage[romanian]{babel}
\usepackage[T1]{fontenc}

\usepackage[sfdefault]{carlito}



\usepackage{indentfirst} % for automatic indentation
%țș
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
}

% For extended customization of titles
\usepackage{titlesec}
% For setting document margins
\usepackage{geometry}
% For enhanced color support
\usepackage{xcolor}

% Set document margins
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Adjusting paragraph indents and spacing
\usepackage{parskip}
\setlength{\parindent}{1em}
\setlength{\parskip}{1em} % Adjust space between paragraphs

% Customizing section titles
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}

% Customizing subsection titles
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}

% Customizing subsubsection titles
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

\begin{document}

\begin{titlepage}

    \begin{minipage}{0.6\textwidth}
        \includegraphics[width=7cm]{logo_ro-RO.png}
    \end{minipage}
    \begin{minipage}{0.3\textwidth}
        \center
        {Programul de studii: \\ Informatic\u{a} Aplicat\u{a}}
    \end{minipage}
    
    \vspace*{5 cm} 

    \begin{center}
            {\Large \textbf{Lucrare de licență \\ Sistem integrat de monitorizare și gestionare a unei parc\u{a}ri auto cu platform\u{a} web interactiv\u{a}}}\\[2 cm]        
    \end{center}

    \vspace*{2 cm} 
    
    {\raggedright \normalsize \textbf{Absolvent:} Doloiu Mihai Alexandru \\ \textbf{Coordonator științific}: Lect. Dr. Vlad Monescu}
    
    \vspace*{\fill} 
    \begin{center}
        {\Large \centering \textbf{Brasov, 2024}}
    \end{center}
\end{titlepage}

\tableofcontents

\newpage

\listoffigures

\newpage

\section{Introducere}

\subsection{Scopul și obiectivele lucrării}

Scopul acestei lucr\u{a}ri de diplom\u{a} este de a dezvolta un proiect care s\u{a} vin\u{a} at\^{a}t \^{i}n ajutorul șoferilor de autovehicule atunci c\^{a}nd sunt nevoiți s\u{a} \^{i}și lase mașina \^{i}n interiorul unei parc\u{a}ri, c\^{a}t și a administratorilor acestor parc\u{a}ri. Pentru realizarea acestui proiect, a fost necesar\u{a} dezvoltarea a dou\u{a} aplicații, una implementat\u{a} \^{i}n limbajul de programare C++ ce se ocup\u{a} de detectarea, recunoașterea și salvarea numerelor de pe pl\u{a}cuțele de \^{i}nmatriculare ale autovehiculelor \^{i}ntr-o baz\u{a} de date, aceasta fiind sistemul de monitorizare și gestionare \^{i}n sine, dar și aplicația destinat\u{a} administratorului parc\u{a}rii, iar cealalt\u{a} aplicație, destinat\u{a} șoferilor, implementat\u{a} \^{i}n limbajul de programare Java și const\u{a} \^{i}ntr-o pagin\u{a} web unde aceștia vor putea vizualiza diferite detalii legate de autovehiculul lor, precum timpul petrecut, data și ora la care au intrat/p\u{a}r\u{a}sit parcarea pentru fiecare sesiune \^{i}n parte, posibilitatea raport\u{a}rii unor probleme dac\u{a} este cazul și a unui mini-chat unde aceștia pot adresa diferite intreb\u{a}ri sau pot afla nout\u{a}ți legate de parcare.

De asemenea, necesitatea unui proiect de acest fel este evident\u{a}, num\u{a}rul de mașini \^{i}n Romania crește de la an la an iar nevoia șoferilor de a avea un loc de parcare pentru propriul autovehicul \^{i}n timpul unei deplas\u{a}ri este absolut necesar\u{a}. Acest proiect ar putea fi utilizat \^{i}n mai multe scenarii: \^{i}ntr-o parcare supraetajat\u{a}, \^{i}n parcarea unui mall, \^{i}n parcarea unui aeroport sau a parc\u{a}rilor din preajma acestuia, și așa mai departe. Spre exemplu, pe durata vizit\u{a}rii unui mall, tot procesul din interiorul parc\u{a}rii ar fi mult mai ușor at\^{a}t pentru șofer, c\^{a}t și pentru dețin\u{a}torul parc\u{a}rii deoarece num\u{a}rul de \^{i}nmatriculare al autovehiculului este detectat, recunoscut și ad\u{a}ugat automat \^{i}ntr-o baz\u{a} de date la intrarea, p\u{a}r\u{a}sirea sau schimbarea unui loc din interiorul parc\u{a}rii, iar șoferul va putea vedea timpul petrecut \^{i}n parcare și costul acesteia, dar și locul pe care a parcat, \^{i}n cazul uit\u{a}rii acestuia, folosind doar c\^{a}teva click-uri.

Obiectivul principal al lucr\u{a}rii este cel menționat mai sus - ajutorul adus at\^{a}t șoferilor de autovehicule, c\^{a}t și a dețin\u{a}torilor de parc\u{a}ri, \^{i}ncerc\^{a}nd automatizarea \^{i}ntregului proces de intrare și ieșire dintr-o parcare. Totuși, realizarea acestui proiect presupune urm\u{a}toarele obiective:

\begin{itemize}
    \item Realizarea detecției pl\u{a}cuței de \^{i}nmatriculare a autovehiculului folosind procesarea de imagini și un model de inteligenț\u{a} artificial\u{a}.
    \item Recunoașterea caracterelor folosind algoritmul de template matching.
    \item G\u{a}sirea locului de parcare pe care un autovehicul a parcat.
    \item Configurarea cu ușurinț\u{a} at\^{a}t a camerelor video, c\^{a}t și a locurilor de parcare din interiorul parc\u{a}rii.
    \item Salvarea tuturor configurațiilor efectuate și a fiec\u{a}rui num\u{a}r de \^{i}nmatriculare detectat, al\u{a}turi de locul \^{i}n care a fost detectat (intrare/ieșire/loc de parcare)
    \item Realizarea unei interfețe c\^{a}t mai prietenoase cu utilizatorul.
    \item Realizarea unei pagini web cu funcționalit\u{a}ți c\^{a}t mai simple, unde șoferii s\u{a} poat\u{a} vizualiza toate detaliile necesare legate de staționarea acestora \^{i}n parcare.
\end{itemize}

\subsection{Motivația alegerii temei}

Motivul principal din spatele alegerii temei pentru dezvoltarea unui sistem de monitorizare și gestionare a unei parc\u{a}ri auto, care integreaz\u{a} dou\u{a} aplicații distincte, este dorința de a crea o soluție complet\u{a} și eficient\u{a} pentru administrarea și utilizarea facilit\u{a}ților de parcare. Prin combinarea unei aplicații \^{i}n C++ ce se ocup\u{a} de detectarea și recunoașterea numerelor de \^{i}nmatriculare, \^{i}mpreun\u{a} cu salvarea acestora \^{i}ntr-o baz\u{a} de date, și a unei aplicații web \^{i}n Java, care servește ca platform\u{a} pentru utilizatorii parc\u{a}rii, se urm\u{a}rește s\u{a} se ofere o soluție cuprinz\u{a}toare și accesibil\u{a}.

Prin intermediul aplicației \^{i}n C++, se pune accent pe automatizarea proceselor de monitorizare a intr\u{a}rilor și ieșirilor dintr-o parcare, contribuind astfel la gestionarea eficient\u{a} a datelor legate de autovehiculele ce utilizeaz\u{a} serviciile parc\u{a}rii. Aceast\u{a} aplicație este esențial\u{a} pentru \^{i}nregistrarea și stocarea precis\u{a} a informațiilor legate de autovehicule.

Pe de alt\u{a} parte, aplicația web \^{i}n Java ofer\u{a} utilizatorilor parc\u{a}rii o interfaț\u{a} intuitiv\u{a} și accesibil\u{a} pentru gestionarea și utilizarea serviciilor oferite. Utilizatorii \^{i}și pot crea cont folosind un cod special primit la intrarea \^{i}n parcare și vor putea astfel s\u{a} acceseze informații detaliate despre parcarea lor, inclusiv istoricul parc\u{a}rii și detaliile legate de locurile de parcare utilizate.

Prin combinarea acestsor dou\u{a} aplicații se dorește s\u{a} se ofere o soluție integrat\u{a} care s\u{a} simplifice procesele de administrare a parc\u{a}rii și s\u{a} \^{i}mbun\u{a}t\u{a}țeasc\u{a} experiența utilizatorilor. 
%țș

\subsection{Structura lucr\u{a}rii}

Lucrarea este \^{i}mp\u{a}rțit\u{a} \^{i}n șapte capitole, care urmeaz\u{a} s\u{a} fie prezentate pe scurt, \^{i}n continuare:


\begin{itemize}
    \item \textbf{Introducere:} Acesta este capitolul introductiv. \^{I}n acest capitol se vor prezenta scopul și obiectivele lucr\u{a}rii, al\u{a}turi de motivația alegerii temei.
    \item \textbf{Medii și concepte de programare: } prezint\u{a} limbajele de programare folosite \^{i}n realizarea proiectului și concepte ce țin de partea de software, design și de procesul de compilare.
    \item \textbf{Detecția pl\u{a}cuțelor de \^{i}nmatriculare: } conține prezentarea \^{i}n detaliu a fiec\u{a}rei p\u{a}rți din cadrul procesului de detecție a pl\u{a}cutelor de \^{i}nmatriculare. Astfel, sunt surprinse diferite informații referitoare la procesarea necesar\u{a} a imaginilor capturate de la camerele video, av\^{a}nd al\u{a}turi și rezultatul obținut dup\u{a} fiecare pas.
    \item \textbf{Recunoașterea caracterelor din pl\u{a}cuța de \^{i}nmatriculare:} conține prezentarea \^{i}n detaliu a fiec\u{a}rei p\u{a}rți din cadrul procesului de recunoaștere a caracterelor din pl\u{a}cuța de \^{i}nmatriculare, de la preprocesarea necesar\u{a}, p\^{a}n\u{a} la aplicarea algoritmului de recunoaștere pe fiecare caracter \^{i}n parte. De asemenea, și \^{i}n acest capitol vor exista imagini cu rezultatul obținut dup\u{a} fiecare pas.
    \item \textbf{Modelarea entităților:} descrie structura datelor și modelarea entităților prezente în sistem, oferind o viziune clară asupra organizării și gestionării datelor.
    \item \textbf{Prezentarea aplicațiilor:} prezint\u{a} \^{i}n detaliu aplicațiile dezvoltate \^{i}n cadrul acestui proiect, cuprinz\^{a}nd fiecare funcționalitate și fiecare meniu din cadrul acestora, precum și arhitecturile folosite \^{i}n organizarea codului.
    \item \textbf{Concluzii și dezvoltări ulterioare:} este o recapitulare a realizărilor principale și o discuție despre potențialele direcții de dezvoltare și îmbunătățire a sistemului.
\end{itemize}

\newpage

\section{Medii si concepte de programare}

\subsection{Limbajul de programare C++}

Inițial denumit "C cu clase", C++ este un limbaj de programare de nivel \^{i}nalt, ce este considerat a fi o extensie și o \^{i}mbunatațire a limbajului C. Acesta p\u{a}streaz\u{a} toate caracteristicile limbajului C și aduce concepte specifice program\u{a}rii orientate pe obiecte, precum clase, obiecte, incapsulare, moștenire, polimorfism, gestionare de excepții și multe altele. Fiind un limbaj de programare orientat pe obiecte, accentul este pus mai mult pe "obiecte" și nu pe manipularea lor. Pe l\^{a}ng\u{a} caracteristica menționat\u{a} anterior, C++ mai dispune și de alte caracteristici la care se num\u{a}r\u{a}: 

\begin{itemize}
    \item Viteza de compilare - deoarece C++ este un limbaj compilat, \^{i}nsemn\u{a}nd c\u{a} codul surs\u{a} al acestuia este tradus direct \^{i}n cod mașin\u{a}, programul rezultat beneficiaz\u{a} de performanțe superioare \^{i}n comparație cu alte limbaje de programare.
    \item Suport pentru pointeri - deși \^{i}n ziua de ast\u{a}zi acest lucru este indisponibil \^{i}n multe alte limbaje de programare, C++ ofer\u{a} o modalitate de a manipula și gestiona direct memoria cu ajutorul pointerilor.
    \item Portabilitate - fiind unul dintre cele mai utilizate limbaje din lume, codul C++ poate fi scris astfel \^{i}nc\^{a}t s\u{a} ruleze pe mai multe platforme hardware și sisteme de operare.
    
\end{itemize}
% cplusplus.com/info/description (ro/en)

Av\^{a}nd \^{i}n vedere caracteristicile menționate \cite{cppref}, acestea contribuie la eficiența și adaptabilitatea sa, facilit\^{a}nd dezvoltarea aplicațiilor pe diverse platforme și \^{i}n diverse contexte. Astfel, fiind unul dintre cele mai importante si puternice limbaje de programare, am decis ca implementarea codului surs\u{a} al aplicației pentru detectarea și recunoașterea numerelor de \^{i}nmatriculare, dar și pentru gestionarea bazei de date a acesteia, s\u{a} fie realizat\u{a} \^{i}n C++.

\subsection{Limbajul de programare Java}

Java, la fel ca și C++, este tot un limbaj de programare de nivel \^{i}nalt, orientat pe obiecte, dar bazat pe clase, unde fiecare fișier este de fapt o clas\u{a}. A fost dezvoltat pentru a oferi portabilitate, performanț\u{a} și securitate, fiind creat cu scopul de a fi independent de platform\u{a}, eficient și simplu. At\^{a}t Java, c\^{a}t și C++, prezint\u{a} numeroase similarit\u{a}ți din punct de vedere al sintaxei limbajului, ins\u{a} limbajul Java este considerat a fi mai ușor de folosit \cite{javaref}. Printre principalele caracteristici ale limbajului Java se num\u{a}r\u{a}:

\begin{itemize}
    \item Programarea orientat\u{a} pe obiecte - Java, la fel ca și C++, dispune de conceptele specifice program\u{a}rii orientate pe obiecte, \^{i}mbun\u{a}t\u{a}țiind practicitatea limbajului de programare prin oferirea unei modalitați mai eficiente de structurare a codului, promov\^{a}nd reutilizarea, flexibilitatea și modularitatea.
    \item Independent de platform\u{a} - programele create \^{i}n Java pot fi rulate pe orice platform\u{a} hardware și sistem de operare datorit\u{a} faptului c\u{a} codul surs\u{a} este tradus \^{i}ntr-un format intermediar numit "Java Bytecode" care permite rularea programului oriunde se dispune de o masin\u{a} virtuala Java instalat\u{a}. JVM-ul (Java Virtual Machine) \^{i}ncarc\u{a}, verific\u{a} și execut\u{a} Java Bytecode-ul, asigur\^{a}nd totodat\u{a} gestionarea memoriei, gestionarea excepțiilor, etc.
    \item Securitate - asupra securit\u{a}ții s-a pus un accent deosebit, fiind asigurat\u{a} prin diverse mecanisme, precum Sandboxing, care const\u{a} \^{i}n izolarea resurselor periculoase ale sistemului de operare prin rularea aplicației Java \^{i}ntr-un mediu controlat. Un alt mecanism este Garbage Collection, care previne scurgerile de memorie si dep\u{a}șirile de buffer.
\end{itemize}

\^{I}n prezent, Java este utilizat \^{i}n diverse aplicații și site-uri web, datorit\u{a} numeroaselor avantaje pe care le ofer\u{a}. Pentru site-ul web prezentat \^{i}n aceast\u{a} lucrare, implementarea acestuia va fi realizat\u{a} cu ajutorul limbajului de programare Java și a framework-ului Spring.

Prin urmare, limbajul de programare Java se remarc\u{a} prin portabilitate, securitate și performanț\u{a}. Datorit\u{a} implement\u{a}rii \^{i}n mod robust a conceptelor fundamentale ale program\u{a}rii orientate pe obiect, se faciliteaz\u{a} crearea de cod bine structurat și ușor de \^{i}ntreținut.

\subsection{Limbajul SQL}

SQL (Structured Query Language) este un limbaj de programare dezvoltat de c\u{a}tre IBM \^{i}n anii 1970 și este folosit pentru gestionarea și manipularea datelor stocate \^{i}ntr-o baz\u{a} de date relațional\u{a} \cite{sqlref}. \^{I}n prezent, acesta este standard pentru majoritatea sistemelor de gestiune a bazelor de date. 

Acest limbaj de programare este folosit \^{i}ntr-o varietate larg\u{a} de aplicații și domenii, de la aplicații web și mobile p\^{a}n\u{a} la sisteme enterprise și analiz\u{a} de date.

Principalele caracteristici ale limbajului SQL sunt:

\begin{itemize}
    \item Structur\u{a} - SQL este un limbaj care utilizeaz\u{a} o sintax\u{a} clar\u{a} și structurat\u{a}, \^{i}mp\u{a}rițit\u{a} \^{i}n mai multe categorii, precum query-uri (interog\u{a}ri), actualiz\u{a}ri, inserții, ștergeri și definiri de tabele și scheme. 
    \item Interog\u{a}ri - Probabil cea mai frecvent\u{a} utilizare a limbajului SQL este pentru interogarea bazelor de date. Cu ajutorul instrucțiunii SELECT, utilizatorii pot extrage date din tabele \^{i}n funcție de anumite criterii.
    \item Actualiz\u{a}ri, inserții și ștergeri: Limbajul SQL permite modificarea datelor existente \^{i}n baza de date prin intermediul instrucțiunilor UPDATE, INSERT și DELETE. Acestea permit utilizatorilor s\u{a} adauge, sa ștearg\u{a} sau s\u{a} actualizeze date din tabelele existente.
    \item Crearea și administrarea tabelelor: SQL permite definirea structurii tabelelor și a altor obiecte din baza de date, precum constr\^{a}ngerile și view-urile, prin utilizarea instrucțiunilor CREATE, ALTER și DROP pentru a crea, a modifica sau a șterge aceste obiecte.
    %țș
\end{itemize}

Astfel. cunoșințele de baz\u{a} \^{i}n limbajul SQL sunt un lucru esențial pentru dezvoltatorii de aplicații software, administratorii de baze de date și analiștii de date, pentru manipularea și gestionarea datelor \^{i}n mod eficient. \^{I}n implementarea aplicațiilor prezentate \^{i}n aceast\u{a} lucrare se folosește o baz\u{a} de date comun\u{a} iar datele din cadrul acesteia sunt accesate și manipulate cu ajutorul interog\u{a}rilor SQL.
%țș

\subsection{Rețele neurale artificiale}

Rețelele neurale artificiale sunt modele matematice inspirate din structura și funcționarea creierului uman, folosite pentru a rezolva probleme complexe. Acestea sunt capabile s\u{a}-și modifice structura intern\u{a} \^{i}n raport cu un obiectiv funcțional. \^{I}n general, sunt potrivite pentru rezolvarea problemelor de tip neliniar reușind s\u{a} reconstituiasc\u{a} reguli neclare ce vor produce o soluție optim\u{a} pentru aceste probleme. Rețelele neurale artificiale sunt alc\u{a}tuite din noduri, numite și elemente de procesare, conexiuni sau neuroni.

Astfel, o rețea neural\u{a} artificial\u{a} este un ansamblu de neuroni interconectați și grupați \^{i}n straturi care funcționeaz\u{a} \^{i}mpreun\u{a} pentru rezolvarea unei probleme.

Un neuron are ca scop reproducerea structurii și funcțion\u{a}rii neuronului biologic, acesta fiind alc\u{a}tuit dintr-un num\u{a}r de intr\u{a}ri, fiecare dintre ele fiind caracterizate de o pondere proprie. Acesta iși poate ajusta valorile ponderilor astfel \^{i}nc\^{a}t pentru un set de perechi de intrare-ieșire s\u{a} returneze un semnal de ieșire av\^{a}nd o eroare minim\u{a}.

\^{I}n timpul antren\u{a}rii rețelei, aceasta \^{i}și ajusteaz\u{a} ponderile conexiunilor \^{i}ntre neuroni pentru a minimiza o funcție de cost, cum ar fi eroarea dintre ieșirile prezise și valorile reale. Acest lucru se realizeaz\u{a} folosind algoritmi de optimizare, cum ar fi gradient descent. Neuronii utilizeaz\u{a} funcții de activare pentru a introduce non-liniaritate \^{i}n rețea, permiț\^{a}ndu-i s\u{a} \^{i}nvețe relații complexe \^{i}ntre datele de intrare și ieșire.

La momentul actual, exist\u{a} o varietate larg\u{a} de arhitecturi de rețele neurale artificiale, adaptate pentru diferite tipuri de probleme și de date. De exemplu, c\^{a}teva arhitecturi populare sunt: rețelele cu straturi complet conectate (fully connected), rețelele convoluționale, rețelele recurente, rețelele generative adversariale (GANs) și altele. Aplicațiile acestor rețele sunt diverse, cum ar fi recunoașterea facial\u{a} sau vocal\u{a}, clasificarea și recunoașterea obiectelor \^{i}ntr-o imagine, procesarea limbajului natural și multe altele.

\^{I}n ultimii ani, au fost realizate progrese semnificative \^{i}n acest domeniu, inclusiv dezvoltarea de noi arhitecturi sau algoritmi de antrenare mai eficienți și tehnici de regularizare pentru a preveni overfitting-ul. Rețelele neurale artificiale sunt astfel un instrument puternic cu aplicații largi și profunde \^{i}n numeroase domenii și industrii.

Totuși, \^{i}n aplicația principal\u{a} ce a fost realizat\u{a} pentru proiectul de diplom\u{a}, pentru detectarea pl\u{a}cuței de \^{i}nmatriculare a unui autovehicul s-a folosit o bibliotec\u{a} ce a permis antrenarea unei rețele neurale convoluționale folosind un set de date propriu și convertirea modelului astfel \^{i}nc\^{a}t s\u{a} se poat\u{a} realiza inferența \^{i}ntr-o aplicație C++.
%țș

\subsection{Rețele neurale convoluționale}

Rețelele neurale convoluționale (CNNs) reprezint\u{a} o ramur\u{a} specializat\u{a} a rețelelor neurale artificiale, adaptat\u{a} pentru prelucrarea și analiza imaginilor. Ele sunt esențiale \^{i}n domeniul viziunii artificiale și au fost dezvoltate pentru abordarea eficient\u{a} a provoc\u{a}rilor specifice ale analizei pe date spațiale, cum ar fi imagini și videoclipuri.

La fel ca și retelele neurale artificiale, și cele convoluționale sunt formate din straturi de neuroni, \^{i}ns\u{a} structura acestora este adaptat\u{a} astfel \^{i}nc\^{a}t s\u{a} se profite de propriet\u{a}țile spațiale ale datelor unei imagini. Aceste rețele utilizeaz\u{a} straturi speciale de convoluție pentru extragerea caracteristicilor relevante dintr-o imagine, reduc\^{a}nd astfel complexitatea datelor și f\u{a}c\^{a}nd posibil\u{a} identificarea de pattern-uri (modele) și obiecte \^{i}n imagini \cite{cnn}.

Pe durata antren\u{a}rii, rețelele convoluționale ajusteaz\u{a} ponderile filtrelor convoluționale pentru a minimiza o funcție de cost, de obicei eroarea dintre predicțiile rețelei și etichetele reale ale imaginilor folosite pentru antrenare. La fel ca la rețelele neurale artificiale, algoritmi de optimizare precum gradient descent sunt folosiți și \^{i}n acest caz.

Una dintre caracteristicile importante ale rețelelor neurale convoluționale este capacitatea lor de a captura caracteristici complexe din imagini, pornind de la caracteristici de baz\u{a} precum marginile și texturile, p\^{a}n\u{a} la caracteristici mai abstracte, precum formele obiectelor sau chiar obiecte \^{i}ntregi.

Aceste rețele sunt folosite \^{i}ntr-o varietate larg\u{a} de aplicații, \^{i}ncluz\^{a}nd p\^{a}n\u{a} și detecția pl\u{a}cuțelor de \^{i}nmatriculare. \^{I}n ultimii ani, au fost obținute progrese semnificative \^{i}n domeniul arhitecturilor de rețele neurale convoluționale, precum ResNet, Inception și EfficientNet, care au \^{i}mbun\u{a}t\u{a}țit performanța și eficiența acestui tip de rețele.
%țș

\subsection{Biblioteca OpenCV}

OpenCV (Open Source Computer Vision Library) este o bibliotec\u{a} open-source specializat\u{a} \^{i}n vedere computerizat\u{a}, procesarea imaginilor și \^{i}nv\u{a}țare automat\u{a}, dețin\^{a}nd peste 2500 de algoritmi ce pot fi utilizați \^{i}n diverse aplicații, precum recunoașterea facial\u{a}, detectarea obiectelor, analiza medical\u{a}. Aceasta a fost scris\u{a} \^{i}n limbajul de programare C++, ins\u{a} este compatibil\u{a} și cu alte limbaje de programare, inclusiv C++, Python, Java și Matlab. \cite{opencv}

Pentru procesarea de imagini, OpenCV ofer\u{a} o gam\u{a} variat\u{a} de funcții pentru manipularea imaginilor, precum conversia de la un spațiu de culoare la altul, ajustarea luminii și a contrastului, transform\u{a}ri geometrice, filtrare și altele. De asemenea, \^{i}n cadrul bibliotecii, exist\u{a} un modul numit OpenCV DNN (Deep Neural Networks), dedicat utiliz\u{a}rii și implement\u{a}rii DNN-urilor \^{i}n aplicații de computer vision. Ofer\u{a} funcționalit\u{a}ți puternice \^{i}n implementarea inferenței modelelor DNN și suporta integrarea cu diferite framework-uri, precum TensorFlow, Caffe, Yolo, Darknet și altele.


\^{I}n proiectul C++, pentru detecția și recunoașterea numerelor de \^{i}nmatriculare ale mașinilor, s-a utilizat versiunea 4.8.0 de OpenCV. Biblioteca a fost utilizat\u{a} de la inceputul proiectului, \^{i}n timpul detect\u{a}rii placuței de \^{i}nmatriculare și a literelor de pe aceasta, unde s-au folosit algoritmii adecvați, p\^{a}n\u{a} la final, la recunoașterea caracterelor, unde s-a folosit un set de date ce conține toate caracterele de pe placuțele din Romania și s-a realizat template matching.

\subsection{Biblioteca YOLOv5}

YOLOv5 (You Only Look Once, versiunea 5), dezvoltat\u{a} de c\u{a}tre echipa Ultralytics, este o bibliotec\u{a} de Deep Learning și un framework pentru detecția diferitelor obiecte \^{i}n imagini și videouri. Ca structur\u{a}, se bazeaz\u{a} pe o abordare de tip "You Only Look Once", \^{i}nsemn\^{a}nd c\u{a} \^{i}n loc ca procesul de detecție s\u{a} fie \^{i}mp\u{a}rțit pe etape separate, cum ar fi detectarea, clasificarea și localizarea, acesta este tratat ca o singur\u{a} rețea neural\u{a}, abordare ce permite furnizarea predicțiilor \^{i}n timp real. Astfel, biblioteca YOLO este cunoscut\u{a} pentru eficiența sa. 

Biblioteca permite utilizatorilor s\u{a} antreneze modele folosind seturi de date proprii, folosind una dintre arhitecturile variate pe care biblioteca le furnizeaz\u{a}, cum ar fi YOLOv5s (Small), YOLOv5m (Medium), YOLOv5l (Large),  și realizarea inferenței (detecție de obiecte) pe imagini noi \cite{yolo}. 

\^{I}n proiectul dezvoltat pentru aceasta lucrare de diplom\u{a}, detecția placuțelor de \^{i}nmatriculare se poate realiza, la alegerea utilizatorului, at\^{a}t prin folosirea algoritmilor de procesare de imagini din OpenCV, c\^{a}t și prin folosirea unui model antrenat cu ajutorul acestei biblioteci.

\subsection{Framework-ul Qt}
%About qt
Qt este un framework utilizat pentru crearea de aplicații cross-platform, precum serverele, care ruleaz\u{a} pe diverse platforme software și hardware, cum ar fi Windows, Linux, OS X, Android, iOS, și altele. Preprocesorul MOC (Meta-Object Compiler) extinde limbajul C++ prin ad\u{a}ugarea de noi caracteristici necesare \^{i}n dezvoltarea aplicațiilor cu interfaț\u{a} grafic\u{a}, cum ar fi semnalele si sloturile. Exist\u{a} numeroase aplicații populare cu interfaț\u{a} grafic\u{a} realizate cu ajutorul framework-ului Qt și folosite de milioane de utilizatori din \^{i}ntreaga lume, printre care se num\u{a}r\u{a} Skype, Google Earth și browser-ul Opera. \cite{qt}

Proiectarea și crearea de GUI (Graphical User Interface) se realizeaza cu ajutorul uneltei grafice incluse in framework, Qt Desginer. Elementele grafice sunt atașate codului prin folosirea mecanismului de sloturi și a semnalelor Qt. Qt Designer genereaz\u{a} automat codul surs\u{a} asociat cu interfața, odat\u{a} ce aceasta este proiectat\u{a}. \cite{qtdesigner} Acest lucru elimin\u{a} nevoia programatorilor de a scrie manual codul pentru fiecare element din interfaț\u{a}, economisind timp și evit\^{a}nd potențialele erori. Proiectarea interfețelor grafice ale aplicațiilor se realizeaza foarte ușor, av\^{a}nd posibilitatea ad\u{a}ug\u{a}rii si configur\u{a}rii a diferitelor elemente GUI, cum ar fi butoanele, etichetele, textbox-uri și altele, utiliz\^{a}nd pur și simplu drag-and-drop. Utilizarea Qt Designer implic\u{a} patru etape de baz\u{a}:
\begin{itemize}
    \item Alegerea propriei interfețe și a obiectelor dorite;
    \item Așezarea obiectelor pe interfața;
    \item Conectarea semnalelor la sloturile corespunz\u{a}toare;
    \item Vizualizarea interfeței.
\end{itemize}

Pentru realizarea interfeței grafice a aplicației principale, responsabil\u{a} pentru detecția și recunoașterea automat\u{a} a numerelor de \^{i}nmatriculare ale mașiniilor, s-a folosit framework-ul Qt 6.4.1. Meniul acesteia ofer\u{a} utilizatorului o metod\u{a} ușoar\u{a} și intuitiv\u{a} de configurare a camerelor video și a locurilor de parcare, folosite pentru monitorizarea traficului din interiorul unei parc\u{a}ri.


\subsection{Framework-ul Spring}
% spring.io/projecta/spring-framework
Spring este un framework open-source și cross-platform, ce ofer\u{a} un model cuprinz\u{a}tor de programare și configurare a aplicațiilor moderne de \^{i}ntreprindere bazate pe limbajul de programare Java. Deoarece se axeaz\u{a} pe suportul infrastructural al aplicațiilor, echipele de dezvoltare pot dedica mai mult timp logicii la nivel de aplicație, f\u{a}r\u{a} leg\u{a}turi inutile cu medii de implementare specifice \cite{spring}. Printre principalele caracteristici ale framework-ului se num\u{a}r\u{a}:
\begin{itemize}
    \item Inversiunea de control - containerul Spring preia responsabilitatea gestion\u{a}rii obiectelor și dependințelor, oferind astfel o structur\u{a} modular\u{a} și ușor de gestionat.
    \item Spring Data - o abordare simplificat\u{a} \^{i}n ceea ce privește lucrul cu baze de date relaționale și non-relaționale.
    \item Spring Web - furnizeaz\u{a} suport pentru dezvoltarea aplicațiilor web, oferind funcționalit\u{a}ți precum gestionarea cererilor HTTP, manipularea parametrilor de solicitare, și facilitarea construirii de aplicații web robuste și scalabile.
    \item Spring Security - se ocup\u{a} de aspectele legate de securitatea aplicațiilor Java, furniz\^{a}nd suport pentru autentificare, autorizare și alte aspecte de securitate.
\end{itemize}

Pentru realizarea aplicației secundare, ce const\u{a} \^{i}ntr-un site web, s-a folosit framework-ul Spring. Datorit\u{a} componentei Spring Security, utilizatorii iși pot crea un cont asociat num\u{a}rului de \^{i}nmatriculare corespunz\u{a}tor mașinii detectate la intrarea din parcare. Odat\u{a} conectați, aceștia pot vizualiza informații, precum timpul petrecut \^{i}n parcare, ora intr\u{a}rii, locurile de parcare unde a fost localizat\u{a} mașina, și transmiterea unor \^{i}ntreb\u{a}ri in cadrul unui chat și a eventualelor pl\^{a}ngeri.

\subsection{Platforma CMake}
%Cmake wikipedia
CMake este un software open-source și cross-platform pentru automatizarea proceselor de build, testing, packaging și instalare a programelor prin utilizarea unei metode independente de compilator. CMake genereaz\u{a} fișierele de compilare ale unui alt sistem, prin urmare acesta nu este un sistem de compilare \cite{cmake}.

Pentru generarea fișierelor de compilare, se vor utiliza fișiere numite "CMakeLists.txt" ce vor fi plasate \^{i}n fiecare director surs\u{a}. Acest lucru funcționeaz\u{a} prin producerea unui mediu de construire nativ unde se vor crea bibliotecile, se vor genera pachetele, se va compila codul surs\u{a} și ulterior va construi executabile.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{structura_cmake.png}
  \caption{Structura directorului surs\u{a} al proiectului principal.}
  \label{fig:structura_cmake}
\end{figure}


\^{I}n figura \ref{fig:structura_cmake} este evidențiat\u{a} structura directorului surs\u{a} al proiectului principal, precum și utilizarea fișierului "CMakeLists.txt". Dup\u{a} ce proiectul este generat și configurat, se creeaz\u{a} directorul "build", unde vor fi prezente toate informațiile necesare rul\u{a}rii proiectului.

\newpage

\section{Detecția pl\u{a}cuțelor de \^{i}nmatriculare}

Aplicația realizat\u{a} a fost aleas\u{a} astfel \^{i}nc\^{a}t s\u{a} fie de ajutor persoanelor sau companiilor ce dețin o parcare, dar și persoanelor ce doresc s\u{a} o foloseasc\u{a}. Utilizarea acesteia poate duce la ușurarea monitoriz\u{a}rii parc\u{a}rii, f\u{a}r\u{a} a mai avea nevoie \^{i}n permanenț\u{a} de un supraveghetor, deoarece detecția si recunoașterea num\u{a}rului de \^{i}nmatriculare al unei mașini se va face automat la apas\u{a}sarea unui buton de c\u{a}tre șoferul acesteia. Odat\u{a} detectat, num\u{a}rul de \^{i}nmatriculare este ad\u{a}ugat \^{i}ntr-o baz\u{a} de date, alaturi de ora intr\u{a}rii și un cod special, numit \textbf{\textit{SecretID}}, ce va permite crearea unui cont de utilizator pe site-ul web destinat aplicației principale sau p\u{a}r\u{a}sirea parc\u{a}rii \^{i}n cazul \^{i}n care, din diverse motive, precum lumina nefavorabil\u{a} sau condiții meteo, num\u{a}rul de \^{i}nmatriculare nu a putut fi identificat. 

\subsection{Preprocesarea imaginilor}

%Diagrama pasi

\subsubsection{Redimensionarea imaginii}

Rezoluția unei imagini se refer\u{a} la detaliul sau claritatea imaginii și este m\u{a}surat\u{a} \^{i}n pixeli. Imaginile preluate de la o camera video pot avea o dimensiune variabil\u{a} \^{i}n funcție de set\u{a}rile sau capacit\u{a}țiile tehnice ale acesteia. Astfel, indiferent de la camera video de la care provine imaginea, se va realiza o redimensionare a acesteia la o rezoluție fix\u{a}, de 640 de pixeli \^{i}n l\u{a}țime și 480 de pixeli \^{i}n \^{i}n\u{a}lțime.

\subsubsection{Conversia imaginii \^{i}n grayscale}

At\^{a}t imaginile preluate de la camerele video ad\u{a}ugate, c\^{a}t și cele destinate test\u{a}rii, sunt imagini de tip BGR, mai precis, imagini care conțin trei canale de culori: canalul albastru (Blue), canalul verde (Green)
și canalul roșu (Red). \^{I}n contextul detect\u{a}rii placuțelor de \^{i}nmatriculare, informația despre culoare nu este esențial\u{a} deoarece asupra imaginii inițiale vor avea loc mai multe operații și identific\u{a}ri de contururi, reduc\^{a}nd astfel complexitatea. Pentru realizarea conversiei unei imagini \^{i}n grayscale s-au folosit 2 metode diferite, "Luminosity" și "Shades of Gray" \cite{grayscale}. 

Metoda "Luminosity" reprezint\u{a} o variant\u{a} mai avansat\u{a} a metodei \^{i}n care se face media valorilor de pe cele 3 canale. \^{I}n esenț\u{a}, aceast\u{a} metod\u{a} calculeaz\u{a} o medie a valorilor, dar utilizeaz\u{a} ponderi pentru a reflecta mai bine percepția uman\u{a} asupra culorilor. Deoarece ochiul uman este mai sensibil la verde dec\^{a}t la alte culori, ponderea pentru verde este cea mai mare \^{i}n calculul mediei ponderate.

Formula pentru realizarea conversiei unui pixel folosind metoda "Luminosity":
\begin{equation}
    P_{\mathrm{gray}}=0.11 \cdot P_\mathrm{blue}+0.59 \cdot P_{\mathrm{green}}+0.30 \cdot P_{\mathrm{red}}
\end{equation}
%https://tannerhelland.com/2011/10/01/grayscale-image-algorithm-vb6.html
\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/originalImage.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayImage.jpg}
  \caption{Imaginea inițial\u{a} (st\^{a}nga); Imaginea convertit\u{a} \^{i}n grayscale folosind "Luminosity" (dreapta)}
  \label{fig:conversie_grayscale}
\end{figure}

Metoda "Shades of Gray" este de asemenea o alta variant\u{a} a metodei \^{i}n care se face media valorilor celor 3 canale, cu diferența c\u{a} putem specifica num\u{a}rul dorit de nuanțe de gri. Este acceptat\u{a} orice valoare cuprins\u{a} \^{i}ntre 2 și 256, unde valoarea 2 va rezulta o imagine alb-negru, iar valoarea 256 va rezulta imaginea asemanatoare conversiei folosind metoda mediei clasic\u{a}. Spre exemplu, \^{i}n figura \ref{fig:conversie_grayscale_custom_shades}, s-au folosit 4 nuanțe pentru conversia imaginii din st\^{a}nga, adic\u{a} negru, gri \^{i}nchis, gri deschis și alb.

Formula pentru realizarea conversiei unui pixel folosind metoda "Shades of Gray":
\begin{equation}
    P_{\mathrm{gray}}=(\frac{(P_\mathrm{blue}+P_{\mathrm{green}}+P_{\mathrm{red}})}{3} \cdot \frac{256}{ShadesNumber}+0.5)\cdot \frac{256}{ShadesNumber}
\end{equation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayShades4.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayShades16.jpg}
  \caption{Imaginea convertit\u{a} \^{i}n grayscale folosind metoda "Shades of Gray", \^{i}n 4 nuanțe de gri (st\^{a}nga); Imaginea convertit\u{a} \^{i}n grayscale folosind metoda "Shades of Gray", \^{i}n 16 nuanțe de gri (dreapta)}
  \label{fig:conversie_grayscale_custom_shades}
\end{figure}

\^{I}n timp ce metoda "Shades of Gray" a oferit rezultate acceptabile \^{i}n anumite condiții, s-a dovedit c\u{a} alegerea unui num\u{a}r de nuanțe prea sc\u{a}zut rezult\u{a} \^{i}n deteriorarea calitații imaginii, pe c\^{a}nd alegerea unui num\u{a}r prea ridicat rezult\u{a} \^{i}n imaginea obținut\u{a} \^{i}n urma folosirii metodei mediei clasice. Prin urmare, metoda "Luminosity" a reprezentat o opțiune mai fiabil\u{a} și mai eficient\u{a}, oferind \^{i}n final cea mai mare acuratețe \^{i}n detecția numerelor de \^{i}nmatriculare.

\subsubsection{Reducerea zgomotului}

Zgomotul \^{i}ntr-o imagine se constituie din perturb\u{a}rile nedorite sau aleatorii care sunt introduse \^{i}n imagine \^{i}n timpul capt\u{a}rii, stoc\u{a}rii, transmiterii sau prelucr\u{a}rii acesteia. Acesta poate avea diverse origini, precum fluctuațiile de lumin\u{a}, interferențele electromagnetice sau erorile de captare a semnalului \cite{filtering}.
%https://www.researchgate.net/publication/338112901_A_Comprehensive_Review_On_Various_Types_of_Noise_in_Image_Processing

Algoritmii de eliminare a zgomotului diminueaz\u{a} sau elimin\u{a} vizibilitatea zgomotului prin uniformizarea \^{i}ntregii imagini, p\u{a}str\^{a}nd totuși regiunile apropiate de limitele de contrast. Cu toate acestea, aceste metode pot masca detalii subtile ale contrastului sc\u{a}zut. Pentru a extrage informații corecte dintr-o imagine, este crucial să minimizăm zgomotul la un nivel cât mai mic posibil.

Pentru reducerea zgomotului, am comparat patru algoritmi ce se g\u{a}sesc \^{i}n biblioteca OpenCV:
\begin{itemize}
    \item Average
    \item Median
    \item Gaussian
    \item Bilateral
\end{itemize}

Filtrul "Average" calculeaz\u{a} valoarea medie a intensitații dintr-o vecin\u{a}tate a fiec\u{a}rui pixel din imagine și o atribuie pixelului corespunz\u{a}tor din imaginea de ieșire. Acest lucru se realizeaz\u{a} prin parcurgerea imaginii cu ajutorului unui kernel (masca) peste imagine, iar fiecare pixel din imaginea de ieșire este calculat ca media pixelilor din fereastra corespunz\u{a}toare din imaginea de intrare. Un kernel de dimensiune 3x3 arat\u{a} \^{i}n felul urm\u{a}tor:

\begin{equation}
    Kernel=\frac{1}{9} \cdot \begin{bmatrix}
        1 & 1 & 1 \\
        1 & 1 & 1 \\
        1 & 1 & 1 
    \end{bmatrix}
\end{equation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayImage.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/averageFilter.jpg}
  \caption{Imaginea inițial\u{a} (st\^{a}nga); Imaginea dup\u{a} aplicarea filtrului "Average" cu un kernel de dimensiune 5x5 (dreapta)}
  \label{fig:filtrul_average}
\end{figure}

Filtrul median funcționeaz\u{a} prin \^{i}nlocuirea valorii fiec\u{a}rui pixel cu valoarea median\u{a} dintr-o regiune vecin\u{a} a acelui pixel. Prin sortarea valorilor pixelilor și alegerea celei din mijloc, acest filtru este eficient \^{i}n reducerea zgomotului impulsiv, cum ar fi "zgomotul s\u{a}rii și piperului", ce const\u{a} \^{i}ntr-o serie de pixeli foarte luminoși sau foarte \^{i}ntunecați, p\u{a}str\^{a}nd totodat\u{a} detaliile marginilor în imagine. Cu toate acestea, poate fi mai lent decât alte filtre, deoarece necesit\u{a} sortarea valorilor din cadrul kernel-ului, iar eficacitatea sa poate fi limitat\u{a} \^{i}n reducerea altor tipuri de zgomot, cum ar fi zgomotul Gaussian. Cu toate acestea, filtrul median r\u{a}m\^{a}ne o unealt\u{a} valoroas\u{a} și larg utilizat\u{a} \^{i}ntr-o varietate de aplicații de procesare a imaginilor. \^{I}n ecuația de mai jos avem ca exemplu valori aleatorii a pixelilor din cadrul kernel-ului de dimensiune 3x3 ce parcurge o imagine și efectueaz\u{a} filtrul median: 

\begin{equation}
        Kernel=\begin{bmatrix}
        5 & 4 & 3 \\
        6 & 9 & 2 \\
        7 & 8 & 1 
    \end{bmatrix} => [5 \quad 4 \quad  3 \quad  6 \quad  9 \quad  2 \quad 7 \quad 8 \quad  1] => [1 \quad 2 \quad  3 \quad  4 \quad  \mathbf{5} \quad  6 \quad 7 \quad 8 \quad  9]
\end{equation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayImage.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/medianFilter.jpg}
  \caption{Imaginea inițial\u{a} (st\^{a}nga); Imaginea dup\u{a} aplicarea filtrului median cu un kernel de dimensiune 5x5 (dreapta)}
  \label{fig:filtrul_median}
\end{figure}

Filtrul Gaussian funcționeaz\u{a} prin aplicarea unui kernel de tip Gaussian peste imagine și convoluționarea acestuia peste imaginea original\u{a}. Acest filtru se caracterizeaz\u{a} prin distribuția lui Gauss, care acord\u{a} o pondere ridicat\u{a} pixelilor din centrul kernel-ului, \^{i}n timp ce pixelii din apropierea marginilor primesc o pondere scazut\u{a}. Filtrul este dat de urm\u{a}toarea formul\u{a}:

\begin{equation}
    G(x,y) = \frac{1}{2\pi\sigma^2} \cdot \mathrm{e}^{-\frac{x^2+y^2}{2\sigma^2}}
\end{equation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayImage.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/gaussianFilter.jpg}
  \caption{Imaginea inițial\u{a} (st\^{a}nga); Imaginea dup\u{a} aplicarea filtrului Gaussian cu un kernel de dimensiune 5x5 (dreapta)}
  \label{fig:filtrul_gaussian}
\end{figure}

Filtrul bilateral folosește dou\u{a} filtre gaussiene separate, unul pentru spațiu, iar cel\u{a}lalt pentru intensitate. Prin aplicarea unui filtru gaussian \^{i}n domeniul spațial se asigur\u{a} c\u{a} doar pixelii vecini sunt considerați \^{i}n procesul de filtrare, p\u{a}str\^{a}nd astfel detaliile structurale ale imaginii. Al doilea filtru, aplicat \^{i}n domeniul intensit\u{a}ții, se asigur\u{a} c\u{a} doar pixelii cu intensit\u{a}ți asem\u{a}n\u{a}toare sunt luați \^{i}n considerare. Aceast\u{a} combinație de filtre permite filtrului bilateral s\u{a} mențin\u{a} marginile clare ale obiectelor din imagine, deoarece pixelii de pe margini vor avea variații mari ale intensit\u{a}ții.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/grayImage.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/bilateralFilter.jpg}
  \caption{Imaginea inițial\u{a} (st\^{a}nga); Imaginea dup\u{a} aplicarea filtrului bilateral cu un kernel de dimensiune 5x5 (dreapta)}
  \label{fig:filtrul_bilateral}
\end{figure}

\^{I}n final, filtrul bilateral s-a dovedit a fi cel mai eficient \^{i}n procesul de detecție a pl\u{a}cuței de \^{i}nmatriculare a unei mașini. Av\^{a}nd \^{i}n vedere capacitatea sa de a menține marginile clare, filtrul bilateral este ideal pentru a evidenția și izola pl\u{a}cuța de \^{i}nmatriculare \^{i}n diverse condiții de lumin\u{a} și \^{i}n prezența a diferitor fundaluri. Acesta a obținut cea mai mare acuratețe \^{i}n procesul de detecție a pl\u{a}cuței de \^{i}nmatriculare pe imaginile din setul de testare, set ce conține imagini din unghiuri nefavorabile, pe timp de zi și noapte, dar și pe condiții meteo mai puțin favorabile, precum z\u{a}pad\u{a}, astfel \^{i}nc\^{a}t detecția pl\u{a}cuțelor de \^{i}nmatriculare s\u{a} ating\u{a} o acuratețe mult mai mare \^{i}n cazul plas\u{a}rii camerei video \^{i}n vederea gestion\u{a}rii unei parc\u{a}ri. Scenariul real se refer\u{a} la capturarea mai multor imagini din 4 fluxuri video, filmate cu un telefon mobil iPhone 12, \^{i}n 1080p, \^{i}n 4 zile diferite, simul\^{a}nd intrarea și p\u{a}r\u{a}sirea a 2 mașini dintr-o parcare.

\begin{figure}[H]
  \centering
  \includegraphics[]{ImaginiPasi/AcurateteFiltre.png}
  \caption{Acuratețea pentru cele 4 filtre \^{i}ncercate, at\^{a}t pe setul de testare, c\^{a}t și \^{i}ntr-un scenariu real.}
  \label{fig:comparatie_filtre}
\end{figure}

\subsubsection{Operația morfologic\u{a} de Opening și Thresholding}
%http://www.cyto.purdue.edu/cdroms/micro2/content/education/wirth08.pdf
Operația morfologic\u{a} de opening const\u{a} \^{i}n aplicarea consecutiv\u{a} a eroziunii și dilat\u{a}rii asupra unei imagini. Prin eroziune, se subțiaz\u{a} obiectele din imagine, \^{i}n timp ce prin dilatare se umplu și se extind zonele r\u{a}mase, ambele operații fiind realizate cu ajutorul unui kernel ce parcurge imaginea și modifica pixelii \^{i}n funcție de vecinii lor \cite{grayscaleopening}. Acest proces este eficient \^{i}n eliminarea zgomotelor mici și a altor artefacte din imagine, p\u{a}str\^{a}nd astfel dimensiunea și forma general\u{a} a obiectelor de interes. \^{I}n aplicația realizat\u{a}, operația morfologic\u{a} de opening este folosit\u{a} at\^{a}t pe imagini binare, c\^{a}t și pe imagini grayscale. Aplicarea acesteia pe o imagine grayscale este asem\u{a}n\u{a}toare cu cea pe imagini binare, diferența fiind aplicarea pe inteinsit\u{a}ți de gri. Prin urmare, eroziunea și dilatarea nu mai sunt efectuate pe valori binare (alb și negru), ci \^{i}n funcție de intensitatea pixelilor. Așadar, pe imaginea rezultat\u{a} \^{i}n urma aplic\u{a}rii filtrului bilateral, se efectueaz\u{a} operația morfologic\u{a} de opening pe imaginea grayscale.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/bilateralFilter.jpg}\hfill
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/extractieOpening.jpg}
  \caption{Imaginea rezultat\u{a} \^{i}n urma aplic\u{a}rii filtrului bilateral (st\^{a}nga); Imaginea rezultat\u{a} dup\u{a} efectuarea operației morfologice de opening cu un kernel de dimensiune 13x13 (dreapta)}
  \label{fig:opening_grayscale}
\end{figure}

\^{I}n continuare, se va efectua operația de sc\u{a}dere \^{i}ntre imaginea obținut\u{a} \^{i}n urma aplic\u{a}rii filtrului bilateral, și imaginea obținut\u{a} dup\u{a} realizarea operației de opening. Operația de sc\u{a}dere const\u{a} \^{i}n sc\u{a}derea valorilor de intensitate ale pixelilor corespunz\u{a}tori din dou\u{a} imagini. Rezultatul acestei operații este o imagine \^{i}n care fiecare pixel din imaginea rezultat\u{a} are o valoare care este diferența dintre valorile de intensitate ale aceluiași pixel din cele două imagini de intrare.
Mai precis, pentru dou\u{a} imagini grayscale, A și B, și un pixel (x, y) din imaginea rezultat\u{a}, rezultatul sc\u{a}derii este:
\begin{equation}
    R(x, y) = A(x, y) - B(x,y)    
\end{equation}
%https://www.tandfonline.com/doi/epdf/10.1080/08839514.2017.1300050?needAccess=true
Pentru a converti o imagine color sau grayscale \^{i}ntr-o imagine binar\u{a}, \^{i}n care pixelii pot avea doar dou\u{a} valori, negru (valoarea 0) sau alb (valoarea 1), se folosește o tehnic\u{a} numit\u{a} thresholding. Aceasta este una dintre cele mai simple tehnici de extragere a obiectelor dintr-o imagine din fundalul acesteia, și const\u{a} \^{i}n alegerea unei valori T ca prag, astfel \^{i}nc\^{a}t valorile pixelilor mai mari dec\^{a}t acest prag devin 1 (alb), iar cele sub acest prag devin 0 (negru).

\begin{equation}
\begin{cases}
1, & f(x,y) \geq T \\
0, & altfel
\end{cases}
\end{equation}

Din diverse motive, cum ar fi culoarea mașinii sau fundalul imaginii, alegerea manual\u{a} a unui prag care sa ofere rezultate optime \^{i}n majoritatea situațiilor nu este posibil\u{a}. Astfel, este nevoie de o soluție prin care pragul T s\u{a} se determine automat, \^{i}n funcție de imaginea de intrare. Determinarea automat\u{a} a unui prag optim se poate realiza cu ajutorul metodelor Otsu și Triangle.

Metoda Triangle (triunghiului) este o tehnic\u{a} de binarizare a imaginilor \^{i}n care pragul optim este ales prin utilizarea unui triunghi dreptunghic. Inițial, se traseaz\u{a} o linie de la maximul histogramei pana la minimul acesteia. Ulterior, pentru alegerea pragului optim se traseaz\u{a} o linie perpendicular\u{a} pe histogram\u{a}, astfel \^{i}nc\^{a}t distanța faț\u{a} de histogram\u{a} s\u{a} fie maximizat\u{a} \cite{segmentation}. Aceast\u{a} abordare funcționeaz\u{a} foarte bine atunci c\^{a}nd \^{i}n histograma imaginii exist\u{a} un singur v\^{a}rf dominant, pragul optim afl\^{a}ndu-se la baza acestuia. \^{I}ns\u{a}, \^{i}n majoritatea imaginilor din setul de testare menționat, s-a observat faptul c\u{a} histograma acestora conține cel puțin dou\u{a} v\^{a}rfuri dominante iar rezultatele obținute \^{i}n urma thresholding-ului nu erau favorabile, așadar, s-a renunțat la aceast\u{a} metod\u{a} \^{i}n favoarea metodei Otsu.

Metoda Otsu, la fel ca și metoda Triangle, este tot o tehnic\u{a} de binarizare a imaginilor, utilizat\u{a} pentru determinarea automat\u{a} a unui prag optim. Aceast\u{a} metod\u{a} se bazeaz\u{a} pe analiza histogramei, propun\^{a}ndu-și s\u{a} g\u{a}seasc\u{a} pragul optim prin ad\u{a}ugarea varianței pixelilor de fundal la varianța pixelilor de prim-plan, pentru toate pragurile posibile, urm\^{a}nd ca pragul optim sa fie cel pentru care suma varianțelor este minim\u{a} \cite{otsu}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.31\linewidth]{ImaginiPasi/extractieOpening.jpg}\hfill
  \includegraphics[width=0.31\linewidth]{ImaginiPasi/extractieSubtract.jpg}\hfill
    \includegraphics[width=0.31\linewidth]{ImaginiPasi/extractieOtsu.jpg}
  \caption{Imaginea rezultat\u{a} \^{i}n urma opening-ului (st\^{a}nga); Imaginea rezultat\u{a} \^{i}n urma sc\u{a}derii (mijloc); Imaginea rezultat\u{a} \^{i}n urma binariz\u{a}rii cu metoda Otsu (dreapta)}
  \label{fig:substract_threshold}
\end{figure}

\subsection{Extragerea contururilor}
%https://www.mecs-press.org/ijisa/ijisa-v8-n3/IJISA-V8-N3-2.pdf
%https://www.mdpi.com/2076-3417/11/14/6292 for undistortion etc

%Suzuki, S. and Abe, K., Topological Structural Analysis of Digitized Binary Images by Border Following. CVGIP 30 1, pp 32-46 (1985)
%https://sci-hub.se/10.1016/0734-189x(85)90016-7
%https://homepages.inf.ed.ac.uk/rbf/HIPR2/label.htm - Detectarea conturilor..
Contururile se descriu ca fiind linia care unește toate punctele continue, de-a lungul unei limite, care au aceași culoare sau intensitate. Acestea sunt utile \^{i}ntr-o varietate de aplicații ce necesit\u{a} analiza și recunoașterea de obiecte \^{i}ntr-o imagine, precum recunoașterea facial\u{a}, detectarea și segmentarea obiectelor, etc.

Detectarea contururilor se poate realiza, de exemplu, prin identificarea tuturor componentelor conexe dintr-o imagine binar\u{a}. Astfel, imaginea este scanat\u{a} și pixelii sunt grupati \^{i}n componente pe baza conectivit\u{a}ții acestora, adic\u{a} toți pixelii dintr-o component\u{a} conex\u{a} care au, \^{i}n cazul unei imagini binare, valoarea 1, pentru reprezentarea unui pixel alb, sau valori similare de intensitate a pixelilor, \^{i}n cazul unei imagini grayscale. Deoarece imaginea candidat este binarizat\u{a}, dup\u{a} determinarea grupurilor de pixeli, componentele conexe vor reprezenta posibila existenț\u{a} a unui obiect iar acestea vor fi etichetate cu o valoare sau o culoare. \^{I}n continuare, dup\u{a} identificarea tuturor componentelor conexe, se va analiza granița dintre obiect și fundal, urm\u{a}nd ca contururile s\u{a} fie determinate de o serie de puncte continue ce delimiteaz\u{a} regiunea obiectului \cite{connectedcomp}. Se observ\u{a} c\u{a}, \^{i}n figura \ref{fig:extractie_all_contours}, num\u{a}rul contururilor este foarte mare, așadar acestea vor trece printr-un proces de filtrare pentru a p\u{a}stra doar contururile relevante ce ar putea delimita placuța de \^{i}nmatriculare. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/extractieAllContours.jpg}
  \caption{Toate contururile din imaginea candidat, colorate \^{i}n verde.}
  \label{fig:extractie_all_contours}
\end{figure}

Pl\u{a}cuța de \^{i}nmatriculare nu este mereu aliniat\u{a} perfect cu axele orizontale și verticale ale imaginii, astfel c\u{a} este nevoie de un obiect care s\u{a} reprezinte un dreptunghi rotit, iar biblioteca OpenCV ofer\u{a} acest lucru prin intermediul clasei RotatedRect. Spre deosebire de clasa Rect, care reprezint\u{a} un dreptunghi aliniat cu axele orizontale și verticale ale imaginii și este definit printr-un punct de origine, prezent \^{i}n colțul din st\^{a}nga sus, și o l\u{a}țime și lungime, clasa RotatedRect este definit\u{a} de o pereche de coordonate reprezent\^{a}nd centroidul dreptunghiului, lungimea și l\u{a}țimea acestuia, dar și un unghi de rotație care specific\u{a} felul \^{i}n care dreptunghiul este rotit \^{i}n jurul centroidului s\u{a}u.

%Begin equation ptr aria drept.
Pentru \^{i}nceptul procesului de filtrare a contururilor, se va g\u{a}si dreptunghiul rotit de cea mai mic\u{a} suprafaț\u{a} care \^{i}ncadreaz\u{a} fiecare contur identificat \^{i}n parte și se va calcula aria acestuia. Deoarece scopul proiectului este de a detecta placuțele de \^{i}nmatriculare dintr-o parcare, am analizat toate imaginile din setul de testare și am observat c\u{a}, \^{i}n medie, aria pl\u{a}cuței de \^{i}nmatriculare este egala cu 2620 pixeli p\u{a}trați. De asemenea, \^{i}ntr-un scenariu real, media ariei a fost de aproximativ 3400 pixeli p\u{a}trați, \^{i}nregistr\^{a}nd o valoare maxim\u{a} a ariei de 4500 pixeli p\u{a}trați. Av\^{a}nd \^{i}n vedere aceste statistici dar și faptul c\u{a} imaginea candidat este redimensionat\u{a} la 640 de pixeli pe l\u{a}țime și 480 de pixeli pe lungime, am decis ca toate contururile a c\u{a}ror arie este mai mic\u{a} de 1000 sau mai mare de 5000 vor fi excluse, renunț\^{a}nd astfel la contururi ce nu sunt relevante, precum alte obiecte din jurul mașinii sau chiar p\u{a}rți din mașin\u{a}, ca de exemplu, farul, roțile sau chiar tabla acesteia, și p\u{a}str\^{a}nd astfel contururile valide \^{i}n care s-ar putea afla pl\u{a}cuța de \^{i}nmatriculare.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/extractieValidContours.jpg}
  \caption{Contururile valide din imaginea candidat, colorate \^{i}n verde.}
  \label{fig:extractie_valid_contours}
\end{figure}

\subsection{Extragerea pl\u{a}cuței de \^{i}nmatriculare}

% https://en.wikipedia.org/wiki/Green%27s_theorem
\^{I}n continuare, dup\u{a} filtrarea contururilor, pentru fiecare contur valid se va calcula aria acestuia folosind funcția contourArea din bliblioteca OpenCV sau utiliz\^{a}nd Teorema lui Green pentru calculul ariei unei regiuni \^{i}n planul xy delimitat\u{a} de un contur C \cite{green}:

\begin{equation}
A = \frac{1}{2} \oint_C x \, dy - y \, dx
\end{equation}

Astfel, ariile contururilor valide vor fi stocate \^{i}ntr-o list\u{a} iar \^{i}n final, se va extrage conturul a c\u{a}rui arie este maxim\u{a} și va fi folosit pentru g\u{a}sirea dreptunghiului de \^{i}ncadrare a conturului respectiv, urm\^{a}nd s\u{a} fie folosit pentru decuparea placuței de \^{i}namtriculare de pe poza original\u{a}. \^{I}n figura \ref{fig:extractie_valid_contours} se poate observa faptul c\u{a} conturul din jurul placuței de \^{i}nmatriculare este conturul a c\u{a}rui arie este maxim\u{a}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/extractieIP1.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare extras\u{a} folosind metoda IMAGE\_PROCESSING.}
  \label{fig:extractie_placuta_opencv}
\end{figure}

\subsection{Metod\u{a} alternativ\u{a} folosind rețele neurale convoluționale}

Pe durata stațion\u{a}rii a unei mașini \^{i}n parcare, camerele destinate locurilor de parcare vor \^{i}ncerca, la un anumit interval de timp, localizarea mașinii \^{i}ntr-unul dintre locurile de parcare configurate. Imaginile capturate de la camerele destinate locurilor de parcare pot conține mai multe mașini. Prin urmare, fiecare loc de parcare configurat este decupat \^{i}ntr-o imagine nou\u{a}, rezult\^{a}nd astfel mai multe imagini, \^{i}n funcție de num\u{a}rul de locuri de parcare acoperite de camera video respectiv\u{a}. Av\^{a}nd \^{i}n vedere distanța dintre camera video și pl\u{a}cuța de \^{i}nmatriculare, calitatea imaginii \^{i}n urma decup\u{a}rii și lu\^{a}nd \^{i}n considerare faptul c\u{a} viteza detecției nu este la fel de important\u{a} ca \^{i}n cazul camerelor destinate intrarii si ieșirii mașinilor, detecția fac\^{a}ndu-se doar la un anumit interval de timp mai ridicat (cel puțin 1 minut), am decis ca metoda folosit\u{a} s\u{a} fie diferit\u{a} faț\u{a} de cea destinat\u{a} celorlalte tipuri de camere video din cadrul aplicației \^{i}n vederea obținerii unor rezultate mai optime. 

Metoda propus\u{a} const\u{a} \^{i}n folosirea rețelelor neurale convoluționale, mai precis, antrenarea unui model folosind biblioteca YOLOv5 pe un set de imagini ce are pl\u{a}cuțele de \^{i}nmatriculare etichetate, și efectu\^{a}nd predicții \^{i}n C++ folosind modulul DNN (Deep Neural Networks) din biblioteca OpenCV.

%țș

\subsubsection{Setul de date utilizat}

\^{I}n antrenarea unui model de rețea neural\u{a} convoluțional\u{a} (CNN), alegerea unui set de date corespunz\u{a}tor este esențial \^{i}n vederea obținerii unui model precis. Pentru a permite modelului s\u{a} \^{i}nvețe caracteristicile relevante pentru problema pe care dorim s\u{a} o rezolv\u{a}m, setul de date trebuie s\u{a} cuprind\u{a} o varietate suficient\u{a} de exemple. Setul de date folosit \^{i}n rezolvarea problemei pentru detecția pl\u{a}cuței de \^{i}namtriculare este o combinație a dou\u{a} seturi de date diferite obținute de pe platforma Roboflow Universe \cite{roboflowuniverse}, dintre care pe unul dintre acestea s-a efectuat augmentarea pe \^{i}ntreg setul cu ajutorul platformei Roboflow.

Roboflow este o platform\u{a} ce ofer\u{a} instrumente și servicii pentru a gestiona și preg\u{a}ti seturi de date pentru diverse aplicații de inteligenț\u{a} artificial\u{a}, precum detectarea obiectelor din imagini, segmentarea semantic\u{a} a obiectelor din imagini, etc. Platforma deține funcționalit\u{a}ți ce au ca scop accelerarea și simplificarea procesului de dezvoltare a aplicațiilor de inteligenț\u{a} artificiala, av\^{a}nd capacitatea de a importa, eticheta, procesa și exporta seturi de date, precum și de a antrena și evalua modelele de inteligenț\u{a} artifical\u{a}. Folosind aceasta platform\u{a}, setul de date a fost augmentat folosind urm\u{a}toarele tehnici: schimbarea luminozit\u{a}ții și a contrastului, ad\u{a}ugare de zgomot, rotire și flip orizonat/vertical.

Roboflow Universe este un ecosistem vast destinat comunit\u{a}ții de inteligent\u{a} artificial\u{a} ce ofer\u{a} o gam\u{a} larg\u{a} de resurse. Prin intermediul Roboflow Universe, utilizatorii au acces la seturi de date deja etichetate și preg\u{a}tite pentru diverse saricini, precum antrenarea unui model de \^{i}nteligenț\u{a} artificial\u{a}.

\^{I}n final, setul de date conține 7593 de imagini dedicate procesului de antrenare, și 2077 de imagini dedicate procesului de validare, av\^{a}nd at\^{a}t imagini capturate din fața mașinilor, c\^{a}t și din spatele lor, dar și imagini ce conțin doar pl\u{a}cuța de \^{i}nmatriculare, f\u{a}r\u{a} a se observa plasarea acesteia pe o mașin\u{a}. Toate imaginile au o dimensiune de 640 de pixeli at\^{a}t \^{i}n lungime, c\^{a}t și \^{i}n l\u{a}țime \^{I}n figura \ref{fig:imagini_set_date} sunt surprinse 6 imagini aleatorii din setul de date.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.30\linewidth]{ImaginiPasi/set1.jpg}\hfill
  \includegraphics[width=0.30\linewidth]{ImaginiPasi/set2.jpg}\hfill
    \includegraphics[width=0.30\linewidth]{ImaginiPasi/set3.jpg}
    \includegraphics[width=0.30\linewidth]{ImaginiPasi/set4.jpg}\hfill
  \includegraphics[width=0.30\linewidth]{ImaginiPasi/set5.jpg}\hfill
    \includegraphics[width=0.30\linewidth]{ImaginiPasi/set6.jpg}
  \caption{Imagini din setul de date.}
  \label{fig:imagini_set_date}
\end{figure}

\subsubsection{Antrenarea modelului}

Arhitectura YOLO este alc\u{a}tuit\u{a} din 3 componente, backbone (schelet), neck (g\^{a}t) și head (cap), toate 3 fiind esențiale pentru structura și funcționarea rețelei. Backbone-ul reprezin\u{a} prima component\u{a} a rețelei iar aceasta este responsabil\u{a} de extragerea caracteristicilor din imaginea de intrare. Urm\u{a}toarea component\u{a}, neck-ul, este o parte intermediar\u{a} care se ocup\u{a} de rafinarea caracteristicilor extrase anterior. \^{I}n final, head-ul reprezint\u{a} partea final\u{a} care este responsabil\u{a} pentru predicția final\u{a}, cum ar fi clasele obiectelor și coordonatele bounding box-urilor.

%Batchsize: 16, img: 640x640, lr = 0.01, epoch: 10, arch: yolov5n
%https://www.researchgate.net/figure/YOLOv5n-network-structure_fig5_364262431
\^{I}n acest stadiu, se definesc și se ajusteaz\u{a} parametrii esențiali ai procesului de antrenare, precum arhitectura modelului, care \^{i}n acest caz este YOLOv5n, dimensiunea batch-ului, setat\u{a} la 16, learning rate-ul, setat la 0.01 și num\u{a}rul de epoci, care este 10. Antrenarea modelului poate fi un proces care poate dura ore sau chiar zile, \^{i}n funcție de m\u{a}rimea setului de date și complexitate modelului. \^{I}n cazul de faț\u{a}, setul de date este relativ mic, conțin\^{a}nd doar o clas\u{a} (pl\u{a}cuța de \^{i}nmatriculare) pentru care se va face predicții. La finalul celei de a 10-a epoc\u{a}, acuratețea a fost de 92,9\% pe setul de validare și 100\% pe setul de testare prezentat la finalul subcapitolului de reducere a zgomotului (3.1.3).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\linewidth]{ImaginiPasi/AcurateteEpoci.png}
  \caption{Acuratețea la inceputul fiec\u{a}rei epoci.}
  \label{fig:acuratete_epoci}
\end{figure}

\subsubsection{Inferența \^{i}n C++}

Odat\u{a} ce modelul a fost antrenat și evaluat cu succes, acesta poate fi utilizat \^{i}n aplicații pentru a face predicții \^{i}n timp real. Astfel, inferența reprezint\u{a} procesul prin care un model antrenat va face predicții pe baza unor date noi de intrare, diferite faț\u{a} de cele din momentul antren\u{a}rii. Pentru realizarea inferenței se va folosi modulul DNN din OpenCV, fiind astfel necesar\u{a} convertirea modelului PyTorch rezultat \^{i}n urma antren\u{a}rii, \^{i}n format ONNX, deoarece la momentul actual modelele antrenate folosind biblioteca YOLOv5 necesit\u{a} convertirea la formatul ONNX.

Pentru realizarea pașilor din cadrul procesului de inferenț\u{a} se va folosi un obiect de tip ObjectDetector ce ofer\u{a} toate funcționalit\u{a}țile necesare, de la \^{i}nc\u{a}rcarea oric\u{a}rui model \^{i}n format ONNX, p\^{a}n\u{a} la afișarea predicțiilor pe o imagine de intrare, oferind posibilitatea utiliz\u{a}rii unui alt model dec\^{a}t cel antrenat anterior dar și a folosirii altor modele ce pot detecta orice num\u{a}r de clase pentru eventuale dezvolt\u{a}ri ulterioare \cite{inference}. 

Primul pas const\u{a} \^{i}n \^{i}ncarcarea arhitecturii și a ponderilor modelului dorit a fi folosit pentru detecția obiectelor. Acesta se poate realiza prin apelarea metodei ChangeDetectionModel din cadrul clasei ObjectDetector, la care se specific\u{a} detaliile necesare legate de modelul \^{i}nc\u{a}rcat, ca de exemplu numele fișierului ONNX, dimensiunile imaginii de intrare, fișierul ce conține lista claselor și un confidence threshold, adic\u{a} acuratețea minim\u{a} necesar\u{a} pentru ca detecția s\u{a} fie considerat\u{a} valid\u{a}.

Dup\u{a} ce modelul a fost \^{i}nc\u{a}rcat, urm\u{a}torul pas este prelucrarea imaginii de intrare ce se realizeaz\u{a} prin intermediul metodei PreProcess, unde are loc scalarea și normalizarea imaginii \^{i}n vederea pregatirii imaginii pentru a fi introdus\u{a} prin rețeaua neural\u{a} \^{i}nc\u{a}rcat\u{a}.

\^{I}n final, au loc ultimii 2 pași, și anume: aplicarea inferenței și desenarea rezultatelor. Se va aplica inferența modelului asupra imaginii de intrare prelucrat\u{a} anterior folosind metoda PostProcess, unde se va inițializa un vector ce va stoca informațiile legate de predicțiile obiectelor și se vor calcula factorii de scalare pentru redimensionarea predicțiilor la dimensiunile imaginii de intrare, urm\^{a}nd extragerea rezultatelor din matricea de ieșire a modelului. Matricea de ieșire conține informații precum coordonatele bounding box-urilor, clasele obiectelor ce au fost detectate și acuratețea predicțiilor rezultate. Predicțiile a c\u{a}ror acuratețe este mai mare sau egala cu valoarea minim\u{a} oferit\u{a} la \^{i}nc\u{a}rcarea modelului (confidence threshold) sunt stocate \^{i}n vectorul inițializat la \^{i}nceput. Pentru selectarea celor mai bune predicții și eliminarea celor redundante se va aplica algoritmul Non-Maximum Suppresion. \^{I}n cele din urm\u{a}, pentru fiecare predicție rezultat\u{a} se poate apela metoda DrawLabel care se va folosi de coordonatele bounding box-ului pentru a desena un dreptunghi \^{i}n jurul obiectului detectat, al\u{a}turi de clasa prezis\u{a}. De asemenea, pentru ușurinț\u{a}, \^{i}n situația detect\u{a}rii pl\u{a}cuțelor de \^{i}nmatriculare, am decis ca pl\u{a}cuța detectat\u{a} sa fie decupat\u{a} și nu desenat\u{a}. Dac\u{a} nu a putut fi detectat\u{a} nicio pl\u{a}cuț\u{a} de \^{i}nmatriculare, atunci se va incerca automat detecția acesteia folosind metoda prezentat\u{a} la \^{i}nceput, denumit\u{a} \textbf{\textit{IMAGE\_PROCESSING}} \^{i}n cadrul proiectului.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/extractieIP1.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/extractieDNN1.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare extras\u{a} folosind metoda IMAGE\_PROCESSING (st\^{a}nga); Pl\u{a}cuța de \^{i}nmatriculare extras\u{a} folosind metoda DNN (dreapta).}
  \label{fig:extractie_dnn}
\end{figure}

\subsection{Concluzie}

Compar\^{a}nd cele dou\u{a} metode de detectare a pl\u{a}cuței de \^{i}nmatriculare, metoda DNN, bazat\u{a} pe tehnologii de inteligenț\u{a} artificial\u{a}, ofer\u{a} o adaptabilitate mai mare la diferite condiții de iluminare și un grad mai mare de generalizare, fiind mai potrivit\u{a} pentru aplicații ce necesit\u{a} o acuratețe c\^{a}t mai mare, pe c\^{a}nd metoda IMAGE\_PROCESSING este mai simpl\u{a} și mai eficient\u{a}, fiind o opțiune bun\u{a} pentru situațiile \^{i}n care timpul de procesare este foarte important. 

Av\^{a}nd \^{i}n vedere c\u{a} camerele video destinate intr\u{a}rii și ieșirii sunt deseori plasate la același nivel cu pl\u{a}cuțele de \^{i}nmatriculare sau la nivelul tavanului, și la o distanț\u{a} scurt\u{a} faț\u{a} de locul \^{i}n care șoferii mașinilor opresc, de exemplu, pentru așteptarea ridic\u{a}rii unei bariere, acuratețea este la fel de bun\u{a} pentru ambele metode. Dac\u{a} num\u{a}rul de \^{i}nmatriculare nu ar putea fi detectat, atunci, \^{i}n cazul intr\u{a}rii, bariera se va deschide oricum și șoferul va primi un cod special, numit \textbf{\textit{SecretID}}, pe care \^{i}l va folosi pentru a p\u{a}r\u{a}si parcarea. De asemenea, pentru aceste tipuri de camere video, timpul de procesare nu ar trebui s\u{a} fie un factor de decizie deoarece diferența de timp dintre cele dou\u{a} metode este de 0.24 secunde și \^{i}n cazul unei cozi la intrare/ieșire, durata \^{i}naint\u{a}rii mașinii spre camera video va dura cu siguranț\u{a} cel puțin doua, trei secunde. Totuși, la folosirea unei camere video de calitate sc\u{a}zut\u{a} sau la plasarea acesteia la o distanț\u{a} mai mare faț\u{a} de mașin\u{a}, metoda aleas\u{a} ar putea conta \^{i}n procesul de detectare a pl\u{a}cuței și de aceea tipul metodei folosite poate fi schimbat oric\^{a}nd din interiorul aplicației C++.

\^{I}n concluzie, alegerea uneia dintre cele dou\u{a} metode depinde at\^{a}t de condițiile și localizarea camerelor video, c\^{a}t și de preferințele personale. Implicit, camerele video destinate intr\u{a}rii și ieșirii vor folosi metoda IMAGE\_PROCESSING, fiind o metod\u{a} mai simpl\u{a} și mai rapid\u{a}, iar camerele video destinate locurilor de parcare vor folosi metoda DNN, deoarece acestea sunt plasate la o distanț\u{a} considerabil\u{a}, astfel \^{i}nc\^{a}t s\u{a} cuprind\u{a} mai multe locuri de parcare, și fiind verificate doar la un anumit interval de timp, pe rand. Timpul de procesare puțin crescut nu va fi oricum sesizat, operația fiind efectuat\u{a} pe alt fir de execuție.

\newpage
 
\section{Recunoașterea caracterelor din pl\u{a}cuța de \^{i}nmatriculare}

Recunoașterea caracterelor, sau OCR (Optical Character Recognition), reprezint\u{a} procesul de identificare și interpretare a textului din imagini sau alte forme de date vizuale. Acesta este utilizat \^{i}ntr-o varietate de domenii, precum digitalizarea documentelor, scanarea codurilor de bare, recunoșterea pl\u{a}cuțelor de \^{i}nmatriculare și multe altele. Totuși, odat\u{a} cu avansarea tehnologiei, algoritmii și tehnicile de recunoștere a caracterelor sunt \^{i}mbun\u{a}t\u{a}țite pentru a fi din ce \^{i}n ce mai precise și mai robuste, ajung\^{a}nd astfel s\u{a} fie utilizate chiar și \^{i}n aplicarea legii, ca de exemplu, aplicarea unei amenzi pentru dep\u{a}șirea limitei maxime de vitez\u{a} admise.

Inițial, procesul \^{i}ncepe prin prelucrarea imaginii care conține text \^{i}n vederea \^{i}mbun\u{a}t\u{a}țirii calit\u{a}ții si clarit\u{a}ții acesteia. Aceasta poate include diverse operații precum, conversia la o imagine grayscale, eliminarea zgomotului, corectarea distorsiunii, etc. \^{I}n continuare este necesar ca fiecare caracter din imagine s\u{a} fie segmentat, aceas\u{a} etap\u{a} fiind crucial\u{a} pentru izolarea fiec\u{a}rui caracter și preg\u{a}tirea acestuia pentru recunoaștere. Dup\u{a} aceea, caracterele sunt extrase și preg\u{a}tite pentru a fi recunoscute, identific\^{a}ndu-se contururile și marginile acestora. \^{I}n final, caracterele extrase sunt recunoscute și convertite \^{i}ntr-un tip de date text (string) folosind diverși algoritmi de recunoaștere a caracterelor ce pot varia \^{i}n funcție de complexitatea și domeniul aplicației, de la rețele neurale, p\^{a}n\u{a} la template matching.

\subsection{Preprocesarea imaginii}

\^{I}nainte de extragerea caracterelor din imaginea de intrare, care este imaginea pl\u{a}cuței de \^{i}nmatriculare detectate anterior, sunt necesare diferite operații pentru \^{i}mbun\u{a}t\u{a}țirea acesteia. Operațiile sunt efectuate \^{i}n ordinea urm\u{a}toare: conversia imaginii \^{i}n grayscale, reducerea zgomotului folosind filtrul gaussian cu un kernel de dimensiune 7x7, egalizarea adaptiv\u{a} a histogramei folosind algoritmul CLAHE \cite{clahe}, redimensionarea imaginii la 400 de pixeli \^{i}n l\u{a}țime și 125 pixeli \^{i}n \^{i}n\u{a}lțime, aplicarea algoritmului de thresholding Otsu și \^{i}n final, unul dintre cei doi algoritmi de corectare a distorsiunii ce vor fi prezentați. 

\^{I}n continuare se va prezenta egalizarea adaptiv\u{a} a histogramei urmat\u{a} de cei doi algoritmi de corectare a distorsiunii, denumiți Undistortioning și Skew Correction, celelalte operații fiind deja prezentate \^{i}n capitolul 3.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereNeProcesata.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoasterePreProcesata.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare detectat\u{a} (st\^{a}nga); Pl\u{a}cuța de \^{i}nmatriculare dup\u{a} preprocesare, f\u{a}r\u{a} corectarea distorsiunii (dreapta).}
  \label{fig:recunoastere_preprocesare}
\end{figure}

\subsubsection{Egalizarea adaptiv\u{a} a histogramei}

%https://svi.nl/ImageHistogram
Histograma unei imagini este o reprezentare grafic\u{a} a num\u{a}rului de pixeli din imagine \^{i}n funcție de intensitatea lor. Acestea sunt alc\u{a}tuire din "bini", fiecare reprezent\^{a}nd un anumit interval de valori de intensitate. Calcularea histogramei se realizeaz\u{a} prin parcurgerea tuturor pixelilor din imagine și atribuirea fiec\u{a}ruia unui bin \^{i}n funcție de intensitatea acestuia \cite{hist}. Astfel, valoarea unui bin reprezin\u{a} num\u{a}rul de pixeli atribuiți acestuia. De exemplu, dac\u{a} primul bin (bin-ul 0) are o valoare de 2500, \^{i}nseamn\u{a} c\u{a} \^{i}n imagine sunt 2500 de pixeli ce au valoarea de intensitate 0 \cite{histogram}.

%https://en.wikipedia.org/wiki/Histogram_equalization
Egalizarea const\u{a} \^{i}n maparea unei distribuții, reprezent\^{a}nd histograma, pe o alt\u{a} distribuție mai larg\u{a} și mai uniform\u{a} a valorilor de intensitate, astfel inc\^{a}t histograma rezultat\u{a} s\u{a} fie c\^{a}t mai uniform\u{a} posibil. Fie P(k) probabilitatea de apariție a intensit\u{a}ții k \^{i}n imaginea inițial\u{a}, iar y noua intensitate atribuit\u{a} lui k dup\u{a} egalizarea histogramei. Pentru o imagine a c\u{a}rui dimensiune total\u{a} este de n pixeli, funcția densit\u{a}ții de probabilitate a intensit\u{a}ții de lumin\u{a} este:

\begin{equation}
    P(k) = \frac{n_k}{n}
\end{equation}

Pentru realizarea efectului de egalizare se va g\u{a}si o noua intensitate y pentru intensitatea inițial\u{a} k folosind funcția de distribuție cumulativ\u{a} definit\u{a} astfel:

\begin{equation}
y = T(k) = \sum_{i=0}^{k} P(i)
\end{equation}

\^{I}n final, noua intensitate pentru fiecare pixel (x,y) din imaginea egalizat\u{a} I' este dat\u{a} de urm\u{a}toarea formul\u{a}:

\begin{equation}
I'(x,y) = T(I(x,y))
\end{equation}

Egalizarea adaptiv\u{a} a histogramei reprezint\u{a} tehnica utilizat\u{a} pentru a \^{i}mbun\u{a}t\u{a}ți contrastul \^{i}n zone cu iluminare inegal\u{a}. Deci, imaginea este \^{i}mp\u{a}rțit\u{a} \^{i}n regiuni mai mici pe care se va aplica egalizarea histogramei \^{i}n mod individual. Aceast\u{a} tehnic\u{a} este folosit\u{a} \^{i}n situațiile \^{i}n care iluminarea unei imagini este inegal\u{a} sau variaz\u{a} semnificativ, lucru ce poate fi \^{i}nt\^{a}lnit \^{i}n scenarii precum imagistic\u{a} medical\u{a} sau camerele de supraveghere, cum este cazul \^{i}n aplicația responsabil\u{a} detect\u{a}rii și recunoașterii pl\u{a}cuței de \^{i}nmatriculare, prezentat\u{a} \^{i}n aceast\u{a} lucrare. 

Pentru realizarea acesteia am folosit algoritmul CLAHE (Contrast Limited Adaptive Histogram Equalization) din OpenCV. Imaginea este \^{i}mp\u{a}rțit\u{a} \^{i}n zone mici numite "tiles", av\^{a}nd un tileSize de 8x8, care este de asemenea și valoarea implicit\u{a} \^{i}n OpenCV. Ulterior, pentru fiecare zon\u{a} histograma intensit\u{a}ților pixelilor este calculat\u{a} și apoi egalizat\u{a}. Totuși, pentru a evita amplificarea zgomotului, se aplic\u{a} o tehnic\u{a} de limitare a contrastului, \^{i}nsemn\^{a}nd c\u{a} dac\u{a} un bin din histograma unei zone dep\u{a}șește o anumit\u{a} limit\u{a} de contrast, pixelii corespunz\u{a}tori sunt redistribuiți uniform \^{i}n alte bin-uri \^{i}nainte de aplicarea egaliz\u{a}rii pe histogram\u{a}. Dup\u{a} aceea, se aplic\u{a} interpolarea biliniar\u{a} \^{i}n jurul marginilor zonelor pentru a asigura o tranziție mai lin\u{a} \^{i}ntre ele. \^{I}n figura \ref{fig:recunoastere_clahe} se poate observa egalizarea imaginii unei pl\u{a}cuțe de \^{i}nmatriculare rezultate \^{i}n urma detecției sale dintr-o imagine.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereOriginal.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereCLAHE.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare detectat\u{a} (st\^{a}nga); Pl\u{a}cuța de \^{i}nmatriculare dup\u{a} aplicarea algoritmului CLAHE (dreapta).}
  \label{fig:recunoastere_clahe}
\end{figure}

\subsubsection{Undistortion}

%https://www.mdpi.com/2076-3417/11/14/6292

Distorsiunile geometrice sunt deform\u{a}ri nedorite a unei imagini care apar ca rezultat al proiecției tridimensionale a obiectelor pe un plan bidimensional, fiind cauzate de faptul c\u{a} obiectelor pot p\u{a}rea diferite \^{i}n imaginea bidimensional\u{a} faț\u{a} de cum arat\u{a} \^{i}n realitate, din cauza unghiurilor de vizualizare și a perspectivei \cite{geometricdistortion}. Exist\u{a} mai multe tipuri de distorsiuni geometrice, dintre care cele mai comune sunt:

%https://www.sciencedirect.com/topics/engineering/geometric-distortion
\begin{itemize}
    \item Distorsiuni de \^{i}nclinare - reprezint\u{a} distorsiunile cauzate de obiectele ce sunt fotografiate sub un anumit unghi, duc\^{a}nd astfel la apariția unei distorsiuni \^{i}n form\u{a} de \^{i}nclinare a acestora. \^{I}n cazul pl\u{a}cuțelor de \^{i}nmatriculare, acesta este tipul de distorsiune geometric\u{a} care va fi corectat, deoarece camera video se poate afla \^{i}n partea st\^{a}ng\u{a} sau dreapt\u{a} a mașinii, la un nivel ridicat faț\u{a} de pl\u{a}cuț\u{a}, astfel cauz\^{a}nd acest tip de distorsiune.
    \item Distorsiuni de scalare - reprezint\u{a} distorsiunile ce apar atunci c\^{a}nd obiectele dintr-o imagine sunt reduse sau m\u{a}rite \^{i}ntr-un anumit raport, ceea ce poate distorsiona proporțiile lor. De exemplu, o imagine a unei mașini care este redimensionat\u{a} \^{i}n l\u{a}țime poate duce la alungirea sau comprimarea acesteia.
    \item Distorsiuni de \^{i}n\u{a}lțime și l\u{a}țime - reprezint\u{a} distorsiunile ce apar atunci c\^{a}nd obiectele sunt v\u{a}zute din unghiuri diferite. De exemplu, dac\u{a} un obiecte este fotografiat sub un unghi lateral poate p\u{a}rea mai lung sau mai lat \^{i}n direcția \^{i}n care este fotografiat, \^{i}n funcție de unghiul de observare.
\end{itemize}

\^{I}n vederea recunoașterii caracterelor dintr-o pl\u{a}cuț\u{a} de \^{i}nmatriculare, corectarea distorsiunilor geometrice este foarte important\u{a} deoarece asigur\u{a} faptul c\u{a} caracterele din pl\u{a}cuț\u{a} sunt reprezentate \^{i}n mod uniform. \^{I}n mare parte, algoritmul ce urmeaz\u{a} a fi prezentat se ocup\u{a} de corectarea \^{i}nclinației și a rotației, elimin\^{a}nd astfel distorsiunile ce pot ap\u{a}rea din cauza unghiurilor de filmare neregulate, și este denumit \^{i}n aplicație: \textbf{\textit{Undistortion}}.

%https://stackoverflow.com/questions/44457064/displaying-stitched-images-together-without-cutoff-using-warpaffine/44459869#44459869
%http://graphics.cs.cmu.edu/courses/15-463/2008_fall/Papers/proj.pdf
%Pribyl, B.; Zemcik, P.; Cadik, M. Absolute pose estimation from line correspondences using direct linear transformation. Comput. Vis. Image Underst. 2017, 161, 130–144. [Google Scholar] [CrossRef] [Green Version]
%16
%Bousaid, A.; Theodoridis, T.; Nefti-Meziani, S.; Davis, S. Perspective Distortion Modeling for Image Measurements. IEEE Access 2020, 8, 15322–15331. [Google Scholar] [CrossRef]
Corectarea acestei distorsiuni se va realiza folosind un proces matematic utilizat pentru a modifica poziția și orientarea unei imagini \^{i}n funcție de un punct de vedere specific sau de o perspectiv\u{a} observat\u{a}, numit transformare de perspectiv\u{a}. Mai precis, acesta implic\u{a} modificarea geometric\u{a} a imaginii astfel \^{i}nc\^{a}t s\u{a} reflecte corect apariția obiectelor atunci c\^{a}nd acestea sunt privite dintr-un unghi sau o poziție specific\u{a}. Aceast\u{a} transformare implic\u{a} calculul unei matrice de transformare H, care s\u{a} reprezinte relația \^{i}ntre poziția original\u{a} a pixelilor din imagine și noua poziție dorit\u{a} \^{i}n imaginea rezultat\u{a}. Elementele matricei H pot fi calculate cu ajutorul algoritmului de transformare liniar\u{a} direct\u{a} (DLT). Totuși, pentru a determina elementele matricei folosind algoritmul DLT, sunt necesare cel puțin cinci perechi de puncte corespunz\u{a}toare, pe c\^{a}nd \^{i}n aceasta lucrare sunt folosite patru puncte \cite{undistortion}. Astfel, matricea de transformarea H se calculeaz\u{a} cu ajutorul unor puncte de origine, care sunt cele patru colțuri ale pl\u{a}cii de \^{i}namtriculare, și cu puncte de destinație, care sunt pozițiile dorite ale acestor colțuri \^{i}n imaginea transformat\u{a}. O transformare liniar\u{a} este exprimat\u{a} prin ecuația:

\begin{equation}
\begin{pmatrix} x' \\ y' \\ 1 \end{pmatrix} = H \cdot \begin{pmatrix} x \\ y \\ 1 \end{pmatrix} = \begin{pmatrix} h_1 & h_2 & h_3 \\ h_4 & h_5 & h_6 \\ h_7 & h_8 & h_9 \end{pmatrix} \cdot \begin{pmatrix} x \\ y \\ 1 \end{pmatrix}
\end{equation}

\^{I}n primul r\^{a}nd, pentru g\u{a}sirea punctelor de origine și de destinație, rezoluția imaginii pl\u{a}cuței de \^{i}nmatriculare este redimensionat\u{a} la o dimensiune fix\u{a}, setat\u{a} la 400 pixeli \^{i}n l\u{a}țime și 125 pixeli \^{i}n \^{i}n\u{a}lțime pe care se va aplica operația de thresholding folosind metoda Otsu, urm\^{a}nd a se obține imaginea pregatit\u{a} pentru corectarea distorsiunii, ca \^{i}n figura \ref{fig:recunoastere_preprocesare}.

Pentru g\u{a}sirea punctelor de origine, adic\u{a} cele patru colțuri ale pl\u{a}cuței de \^{i}nmatriculare se va clona imaginea preprocesat\u{a} p\^{a}n\u{a} \^{i}n acest punct iar pe aceasta se va c\u{a}uta cel mai mare contur, care va fi conturul pl\u{a}cuței de \^{i}nmatriculare. Odat\u{a} g\u{a}sit conturul, se va colora cu alb interiorul acestuia, elimin\^{a}nd astfel caracterele din interiorul pl\u{a}cii deoarece sunt irelevante \^{i}n g\u{a}sirea colțurilor pl\u{a}cuței. De asemenea, se va efectua și o operație morfologic\u{a} de opening \^{i}n care erodarea va folosi un kernel de dimensiune 7x7 iar dilatarea un kernel de dimensiune 5x5.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoasterePreProcesata.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoasterePlacutaFaraScris.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare preprocesat\u{a} (st\^{a}nga); Pl\u{a}cuța de \^{i}nmatriculare dup\u{a} eliminarea caracterelor și opening (dreapta)}
  \label{fig:recunoastere_clona}
\end{figure}

\^{I}n continuare, se vor identifica toate colțurile pl\u{a}cuței de \^{i}nmatriculare prin obținerea unui poligon simplificat care aproximeaz\u{a} forma acesteia. Acest lucru se realizeaza cu ajutorul funcției approxPolyDP din biblioteca OpenCV, iar valorile poligonului rezultat reprezint\u{a} colțurile pl\u{a}cuței. Toate aceste coordonate ale colțurilor sunt ulterior sortate descrescator \^{i}n funcție de coordonata lor pe axa X. Dup\u{a} sortare, primele dou\u{a} colțuri din lista vor fi cele din partea dreapt\u{a} a pl\u{a}cuței. Deși ultimele dou\u{a} colțuri din lista ar reprezenta colțurile din partea st\^{a}ng\u{a}, din cauza literelor prezente pentru identificarea ț\u{a}rii de origine a pl\u{a}cuței, este posibil ca dup\u{a} operația de opening s\u{a} existe \^{i}n continuare un gol \^{i}n aceast\u{a} zon\u{a}, asem\u{a}n\u{a}tor ca \^{i}n figura \ref{fig:recunoastere_clona}, duc\^{a}nd astfel identificarea unor colțuri suplimentare \^{i}n interiorul acesteia. Pentru rezolvarea acestei probleme, se vor parcurge toate colțurile identificate din partea st\^{a}ng\u{a} și se vor g\u{a}si colțurile a c\u{a}rui coordonat\u{a} pe ax\u{a} Y este maxim\u{a}, respectiv minim\u{a}. Pentru a decide care dintre colțuri se afl\u{a} \^{i}n partea de sus și care se afl\u{a} \^{i}n partea de jos se va face o verificare pe baza coordonatelor de pe axa Y. De exemplu, dac\u{a} coordonata Y a unui colț c1 este mai mic\u{a} dec\^{a}t coordonata Y a altui colț c2, ambele afl\^{a}ndu-se pe aceași parte, atunci colțul c1 va fi poziționat st\^{a}nga sus iar c2 va fi poziționat st\^{a}nga jos. At\^{a}t punctele de origine finale, c\^{a}t și cele de destinație, vor fi ad\u{a}ugate \^{i}ntr-o list\u{a} \^{i}n urm\u{a}toarea ordine: st\^{a}nga sus, dreapta sus, st\^{a}nga jos, dreapta jos. \^{I}n figura \ref{fig:recunoastere_puncte} se pot observa toate colțurile identificate, colțurile selectate pentru partea st\^{a}ng\u{a} sunt colorate cu verde, pentru partea dreapt\u{a} sunt colorate cu roșu, și cu albastru sunt colorate restul colțurilor ce au fost identificate, dar nu și selectate.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.48\linewidth]{ImaginiPasi/recunoasterePuncteUndistortion.jpg}
  \caption{Colțurile identificate \^{i}n pl\u{a}cuța de \^{i}nmatriculare}
  \label{fig:recunoastere_puncte}
\end{figure}

Este important s\u{a} obținem aceste colțuri cu precizie, deoarece orice eroare \^{i}n identificarea lor va afecta negativ transformarea și ar putea duce la distorsiuni \^{i}n imaginea rezultată. Pe baza conturului pl\u{a}cuței se va g\u{a}si și dreptunghiul rotit de cea mai mic\u{a} suprafaț\u{a} care \^{i}l \^{i}ncadreaz\u{a} iar cu ajutorul acestuia se va decide, pe baza unghiului de rotație, dac\u{a} este necesar\u{a} transformarea sau nu.

Punctele de destinație sunt stabilite astfel \^{i}nc\^{a}t imaginea pl\u{a}cuței de \^{i}nmatriculare rezultat\u{a} din corectarea distorsiunii s\u{a} corespund\u{a} unei forme geometrice dreptunghiulare orientate frontal. Astfel, coordonatele fiec\u{a}rui colț al dreptunghiului este determinat \^{i}n funcție de dimensiunea imaginii WxH, unde W reprezint\u{a} l\u{a}țimea și H reprezint\u{a} \^{i}n\u{a}lțimea și care implicit are dimensiunea 400x125, \^{i}ns\u{a} constanta poate fi modificat\u{a} din interiorul codului, din clasa Utils. Formula pentru determinarea coordonatelor punctelor de destinație este: 

\begin{equation}
\begin{pmatrix} (x,y)_\mathrm{TopLeft} \\ (x,y)_\mathrm{TopRight} \\ (x,y)_\mathrm{BottomLeft} \\ (x,y)_\mathrm{BottomRight} \end{pmatrix}  = \begin{pmatrix} (\frac{W}{8}, \frac{H}{3}) \\ (W-\frac{H}{3}, \frac{H}{3}) \\ (\frac{W}{8}, \frac{2 \cdot H}{3}) \\ (W-\frac{H}{3}, \frac{2 \cdot H}{3}) \end{pmatrix} 
\end{equation}

Deoarece au fost aflate toate punctele necesesare pentru calculul matricei de transformare, se dorește p\u{a}strarea doar a caracterelor din interiorul pl\u{a}cuței și realizarea transform\u{a}rii pe o imagine ce le include doar pe acestea. Av\^{a}nd deja at\^{a}t punctele de origine c\^{a}t și cele de destinație, faptul c\u{a} se exclud restul detaliilor din imagine este neimportant, punctele av\^{a}nd oricum aceleași coordonate. Astfel, pentru a p\u{a}stra doar caracterele din imagine se va realiza o operație \^{i}n care se compar\u{a} valoarea pixelilor din imaginea pl\u{a}cuței de \^{i}nmatriculare ce nu include caracterele, notat\u{a} cu A, cu imaginea pl\u{a}cuței de \^{i}nmatriculare original\u{a}, rezultat\u{a} \^{i}n urma preproces\u{a}rii, notat\u{a} cu B. Scopul este s\u{a} avem pixelii corespunz\u{a}tori caracterelor colorați cu negru, adica valoare pixelilor s\u{a} fie 0, și ceilalți pixeli s\u{a} fie colorați cu alb, adica valoarea pixelilor s\u{a} fie 255. Pixelii ce au deja valoarea 255 vor r\u{a}m\^{a}ne la fel, cei a c\u{a}ror valoare este egal\u{a} \^{i}n ambele imagini vor lua valoarea 255, iar pixelii a c\u{a}ror valoare este 255 (alb) \^{i}n imaginea A dar este 0 (negru) \^{i}n imaginea B, vor lua valoarea 0 (negru), obțin\^{a}nd astfel o imaginea ce va conține doar caracterele, cu eventualitatea aparițiilor a unor pixeli de valoare 0 ce nu corespund unui caracter. Aceștia vor fi eliminați dup\u{a} corectarea distorsiunii, \^{i}n capitolul 4.2. Mai precis, pixelii vor fi modificați utiliz\^{a}nd urm\u{a}toarea formul\u{a}:

\begin{equation}
\begin{cases}
0, & A(x,y) = 255 \text{ și } B(x,y) = 0 \\
1, & altfel
\label{eq:bitwise}
\end{cases}
\end{equation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoasterePlacutaFaraScris.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoasterePreProcesata.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoastereCleanPlateFinal.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare dup\u{a} eliminarea caracterelor și opening (st\^{a}nga); Pl\u{a}cuța de \^{i}nmatriculare original\u{a}, preprocesat\u{a} (mijloc); Caracterele din interiorul pl\u{a}cuței (dreapta)}
  \label{fig:recunoastere_bitwise}
\end{figure}

Transformarea de perspectiv\u{a} se va realiza pe imaginea obținut\u{a}, ce conține doar caracterele imaginii și utiliz\^{a}nd matricea de transformare H calculat\u{a} cu ajutorul punctelor de origine și destinație g\u{a}site. \^{I}n figura \ref{fig:recunoastere_rezultat} se poate observa corectarea distorsiunii geometrice, caracterele nefiind \^{i}nclinate.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereCleanPlateFinal.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereUndistortion.jpg}
  \caption{Caracterele din interiorul pl\u{a}cuței (st\^{a}nga); Caracterele din interiorul pl\u{a}cuței dup\u{a} corectarea distorsiunii folosind Undistortion (dreapta)}
  \label{fig:recunoastere_rezultat}
\end{figure}

\subsubsection{Skew Correction}

Asem\u{a}n\u{a}tor cu algoritmul prezentat antrerior,  și \textbf{SkewCorrection} (corectarea \^{i}nclin\u{a}rii) este tot un proces \^{i}n prelucrarea imaginilor ce se ocupa cu corectarea oric\u{a}rei \^{i}nclin\u{a}ri sau distorsiuni dintr-o imagine. 

Acest proces const\u{a} \^{i}n detecția unghiului de rotație cu ajutorul dreptunghiului rotit de cea mai mic\u{a} suprafaț\u{a} care \^{i}ncadreaz\u{a} conturul maxim g\u{a}sit \^{i}n imaginea pl\u{a}cuței de \^{i}nmatriculare. Dup\u{a} obținerea unghiului, se verific\u{a} dac\u{a} imaginea are nevoie de aplicarea algoritmului Skew Correction cu ajutorul valorii unghiului. Dac\u{a} unghiul este mai mare de 85 de grade sau mai mic de 5 grade, atunci imaginea pl\u{a}cuței nu necesit\u{a} aplicarea acestui pas, imaginea fiind aproape, sau chiar deloc \^{i}nclinat\u{a}.

\^{I}n continuare, se va calcula matricea de rotație specific\^{a}nd centrul rotației, unghiul de rotație, astfel \^{i}nc\^{a}t s\u{a} fie \^{i}ntre -45 și 45 de grade, și un factor de scalare care este 1.0 \^{i}n acest caz. Matricea de rotație este un tip specific de matrice de transformare ce descrie o rotație aplicat\u{a} unei imagini sau a unui obiect geometric din jurul unui anumit punct sau ax\u{a}. \^{I}ntr-un spațiu bidimensional, matricea de rotație este de dimensiune 2x2 și este definit\u{a} \^{i}n funcție de unghiul de rotație. O matrice de rotație pentru unghiul specific de rotație \ensuremath{\theta} este definit\u{a} astfel:

\begin{equation}
M =
\begin{bmatrix}
\cos(\theta) & -\sin(\theta) \\
\sin(\theta) & \cos(\theta)
\end{bmatrix}
\end{equation}

\^{I}n final, se aplic\u{a} transformarea afin\u{a} folosind funcția warpAffine din biblioteca OpenCV cu matricea de rotație calculat\u{a}, pentru a roti imaginea ce conține caracterele din interiorul pl\u{a}cuței de \^{i}nmatriculare. Pentru obținerea imaginii ce conține doar caracterele pl\u{a}cuței, imaginea original\u{a} a acesteia este clonat\u{a} și colorat\u{a} cu alb pe suprafața celui mai mare contur g\u{a}sit. Dup\u{a} aceea, se va modifica fiecare pixel dintre imaginea original\u{a} și imaginea obținut\u{a} anterior folosind formula prezentat\u{a} \^{i}n ecuația \ref{eq:bitwise}. Dup\u{a} rotire se pot crea spații goale \^{i}n jurul imaginii iar pentru aceast lucru se folosește interpolarea cubic\u{a}. Aceasta este folosit\u{a} pentru estimarea valorilor pixelilor din spațiile goale. \^{I}n figura \ref{fig:recunoastere_rezultat_skew} se poate observa corectarea distorsiunii folosind tehnica prezentat\u{a}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereCleanPlateFinal.jpg}\hfill
    \includegraphics[width=0.40\linewidth]{ImaginiPasi/recunoastereSkewCorrection.jpg}
  \caption{Caracterele din interiorul pl\u{a}cuței (st\^{a}nga); Caracterele din interiorul pl\u{a}cuței dup\u{a} corectarea distorsiunii folosind SkewCorrection (dreapta)}
  \label{fig:recunoastere_rezultat_skew}
\end{figure}

\subsubsection{Rezultatele celor dou\u{a} metode de corectare a distorsiunii}

\^{I}nc\u{a} de la prima vedere se poate observa faptul c\u{a} algoritmul SkewCorrection a obținut o \^{i}nclinare dreapt\u{a} a textului din interiorul pl\u{a}cuței de \^{i}nmatriculare, dar nu și a caracterelor, acestea fiind puțin \^{i}nclinate spre st\^{a}nga, așa cum se poate observa \^{i}n figura \ref{fig:recunoastere_rezultat_skew}. Acest lucru se poate \^{i}ntampla și \^{i}n cazul metodei Undistortion atunci c\^{a}nd cele 4 colțuri ale pl\u{a}cuței nu sunt alese cu precizie, \^{i}ns\u{a} alegerea acestora poate fi \^{i}mbun\u{a}t\u{a}țit\u{a}, pe c\^{a}nd g\u{a}sirea unui contur mai precis \^{i}n cazul metodei SkewCorrection va duce la același unghi de rotație și prin urmare, la aceeași imagine rezultat\u{a}. De asemenea, \^{i}n urma aplic\u{a}rii ambelor metode pe fiecare imagine din setul de testare, s-a constat c\u{a} metoda SkewCorrection corecteaz\u{a} \^{i}nclinarea textului pe aproape fiecare imagine \^{i}ns\u{a} din cauza \^{i}nclin\u{a}rii caracterelor, acestea nu pot fi recunoscute cu succes \^{i}n pasul urm\u{a}tor, pe c\^{a}nd metoda Undistortion, deși nu corecteaz\u{a} distorsiunea geometric\u{a} cu o acuratețe la fel de mare, atunci cand vine vorba de recunoașterea caracterelor, aceast\u{a} metod\u{a} c\^{a}știg\u{a} detașat, av\^{a}nd o acuratețe de peste dou\u{a} ori mai mare \^{i}n recunoașterea \^{i}ntregului text de pe pl\u{a}cuțele de \^{i}nmatriculare.

Metoda Undistortion este adesea considerat\u{a} o abordare superioar\u{a} \^{i}n comparație cu SkewCorrection \^{i}n contextul corect\u{a}rii distorsiunilor dintr-o imagine. Metoda Undistortion aplic\u{a} transform\u{a}ri complexe pentru corectarea distorsiunilor geometrice, asatfel \^{i}nc\^{a}t obiectele s\u{a} apar\u{a} cu forme și proporții corecte \^{i}n imagine, acest lucru fiind esențial \^{i}n contextul aplicațiilor ce necesit\u{a} o precizie ridicat\u{a}, precum recunoașterea caracterelor. \^{I}n schimb, metoda SkewCorrection se concentreaz\u{a} pe ajustarea orient\u{a}rii obiectelor din imagine, lucru ce poate fi suficient \^{i}n unele aplicații, dar nu corecteaz\u{a} complet distorsiunile geometrice. Prin urmare, metoda folosit\u{a} \^{i}n continuare pentru recunoașterea caracterelor este \textbf{Undistortion}. \^{I}n figura \ref{fig:recunoastere_rezultate} se observ\u{a} rezultatele ambelor metode pe diferite imagini a unor pl\u{a}cuțe de \^{i}nmatriculare.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV75XXL.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV75XXL_skew.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV75XXL_undist.jpg}
    
     \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV71AXE.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV71AXE_skew.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV71AXE_undist.jpg}
    
     \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV04PDB.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV04PDB_skew.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV04PDB_undist.jpg}

     \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV19PIW.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV19PIW_skew.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPlacute/BV19PIW_undist.jpg}

      \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoasterePreProcesata.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoastereSkewCorrection.jpg}\hfill
    \includegraphics[width=0.33\linewidth]{ImaginiPasi/recunoastereUndistortion.jpg}
  \caption{Pl\u{a}cuța de \^{i}nmatriculare (st\^{a}nga); Corectarea distorsiunii folosind SkewCorrection (mijloc); Corectarea distorsiunii folosind Undistortion (dreapta)}
  \label{fig:recunoastere_rezultate}
\end{figure}

\subsection{Detectarea caracterelor}

Recunoașterea caracterelor din interiorul pl\u{a}cuței nu se va face utiliz\^{a}nd \^{i}ntreg textul, ci pe fiecare caracter \^{i}n parte. Așadar, este necesar ca fiecare caracter s\u{a} fie detectat și salvat pentru aplicarea algoritmului de recunoștere a acestuia. Av\^{a}nd deja o imagine cu fundal alb ce conține tot interiorul pl\u{a}cuței, detectarea caracterelor se face foarte simplu, g\u{a}sind toate contururile din aceast\u{a} imagine și selectarea celor relevante. Tehnica pentru extragerea contururilor este aceași ca cea prezentat\u{a} \^{i}n capitolul 3.2, unde s-a realizat detectarea pl\u{a}cuței de \^{i}nmatriculare.

Totuși, este important de evidențiat c\u{a} nu toate contururile g\u{a}site reprezint\u{a} un caracter valid. Unele dintre aceste contururi pot fi rezultatul zgomotului sau a artefactelor din imagine, iar altele ar putea fi segmente din caracterele deja existente, de exemplu, pentru litera "O" ar putea exista 2 contururi diferite, unul fiind litera \^{i}n sine, iar cel\u{a}lalt fiind interiorul acesteia, rezult\^{a}nd astfel \^{i}n dou\u{a} litere "0" recunoscute. De asemenea, \^{i}n Rom\^{a}nia, \^{i}n urma finaliz\u{a}rii cu succes a inspecției tehnice periodice (ITP) la mașin\u{a}, unii șoferi primesc un abțibild de dimensiune mic\u{a} și rotund pe care ajung s\u{a} \^{i}l lipeasc\u{a} pe interiorul pl\u{a}cuței de \^{i}nmatriculare. \^{I}n consecinț\u{a}, este necesar\u{a} aplicarea unui proces de filtrare și validare a contururilor g\u{a}site pentru a asigura c\u{a} doar caracterele reale sunt recunoscute și interpretate corect.

Procesul de filtrare și validare implic\u{a} plasarea unui dreptunghi \^{i}n jurul fiec\u{a}rui contur, delimit\^{a}nd astfel o regiune de interes care ar putea include un caracter. Acest dreptunghi care \^{i}nconjoar\u{a} conturul este folosit pentru izolarea și extragerea caracterului corespunz\u{a}tor din imaginea original\u{a}, adic\u{a} imaginea rezultat\u{a} \^{i}n urma corect\u{a}rii distorsiunilor. Pentru a decide dac\u{a} un contur este valid sau nu, acesta trebuie s\u{a} \^{i}ndeplineasc\u{a} urm\u{a}toarele condiții: \^{i}n\u{a}lțimea dreptunghiului este mai mare dec\^{a}t 20\% din \^{i}n\u{a}ltimea imaginii originale și l\u{a}țimea dreptunghiului este mai mic\u{a} dec\^{a}t jum\u{a}tate din l\u{a}țimea imaginii originale, iar aria conturului s\u{a} fie cuprins\u{a} \^{i}ntre 75 și 4000. \^{I}n continuare, pentru fiecare contur valid se va salva imaginea acestuia, rezultat\u{a} \^{i}n urma decup\u{a}rii din imaginea original\u{a} folosind dreptunghiul acestuia iar acestea vor fi plasate \^{i}ntr-un vector ce conține perechi de tipul cv::Mat, cv::Rect, unde cv::Mat reprezint\u{a} imaginea caracterului și cv::Rect reprezint\u{a} dreptunghiul ce \^{i}l \^{i}nconjoar\u{a}. Salvarea dreptunghiului este necesar\u{a} pentru sortarea contururilor dup\u{a} coordonata axei X, astfel \^{i}nc\^{a}t s\u{a} se obțina ordinea corect\u{a} a caracterelor din textul pl\u{a}cuței. Dup\u{a} sortare, fiecare contur valid este parcurs și analizat pentru a se asigura faptul c\u{a} acesta nu face parte din interiorul altui contur, așa cum este \^{i}n exemplul prezentat mai sus \^{i}n cazul literei "O".

\^{I}n final, dup\u{a} ce contururile sunt filtrate și validate, se consider\u{a} c\u{a} aplicarea algoritmului pentru recunoașterea caracterelor \^{i}ndeplinește toate condițiile necesare, asigur\^{a}nd c\u{a} doar datele relevante vor fi transmise. Atunci c\^{a}nd algoritmul va parcurge contururile valide, acesta va porni de la primul caracter, adic\u{a} cel mai din st\^{a}nga, p\^{a}n\u{a} la ultimul caracter, adic\u{a} cel mai din dreapta, deoarece caracterele au fost sortate dup\u{a} localizarea acestora. De asemenea, este inc\u{a} posibil ca unele contururi s\u{a} nu reprezinte un caracter valid, \^{i}ns\u{a} algoritmul pentru recunoșterea acestora va elimina la r\^{a}ndul s\u{a}u alte date irelevante.

\subsection{Template Matching}

% de pe opencv
Template matching reprezint\u{a} o metod\u{a} de c\u{a}utare și g\u{a}sire a locației unei imagini șablon \^{i}ntr-o imagine mai mare. Aceasta gliseaz\u{a} imaginea șablon peste imaginea de intrare, asem\u{a}n\u{a}tor ca \^{i}n convoluția 2D, și compar\u{a} șablonul și fragmentul de imagine de intrare sub imaginea șablon. \^{I}n final, rezultatul este o imagine grayscale \^{i}n care fiecare pixel indic\u{a} c\^{a}t de mult se aseam\u{a}n\u{a} vecin\u{a}tatea acelui pixel cu șablonul. Dac\u{a} imaginea de intrare are dimensiunea WxH și imaginea șablon are dimensiunea wxh, imaginea de ieșire va avea dimensiunea W-w+1, H-h+1 \cite{templatematching}. Dup\u{a} obținerea rezultatului, se va afla valoarea maxim\u{a} care va determina care dintre caractere seaman\u{a} cel mai mult cu imaginea de intrare, care \^{i}n cazul recunoașterii pl\u{a}cuțelor de \^{i}nmatriculare, va fi imaginea unui caracter din textul acesteia.

Pentru \^{i}nceput, se va alege ca imagine de intrare, o imagine care conține litera sau cifra care urmeaz\u{a} s\u{a} fie recunoscut\u{a}.  \^{I}n recunoașterea caracterelor de pe pl\u{a}cuța de \^{i}nmatriculare, imaginea reprezint\u{a} o anumit\u{a} liter\u{a} sau cifr\u{a} din interiorul acesteia. Av\^{a}nd deja o list\u{a} sortat\u{a} cu toate caracterele pl\u{a}cuței, se va considera, pe r\^{a}nd, fiecare element ca fiind imaginea de intrare, urm\^{a}nd a se executa algoritmul pentru fiecare dintre caracterele acesteia. Aceste imagini de intrare sunt comparate mai departe cu o alt\u{a} list\u{a} de imagini, predefinite, numite imagini template, care conțin toate caracterele și cifrele posibile pe pl\u{a}cuțele din Rom\^{a}nia \cite{templatematchingart}. De asemenea, acest set de imagini poate fi modificat astfel \^{i}nc\^{a}t sa conțin\u{a} și alte caractere dintr-un alt alfabet prin simpla ad\u{a}ugare/ștergere a unor imagini \^{i}n folderul specific acestuia (CharTemplates) și \^{i}n fișierul text numit "charTemplates.txt" din interiorul folderului Resources, unde se afl\u{a} lista imaginilor dorite. Denumirea imaginilor trebuie sa \^{i}nceap\u{a} neap\u{a}rat cu litera care se afl\u{a} \^{i}n imaginea template.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/0ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/1ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/2ro.jpg}
     \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/3ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/4ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/5ro.jpg}
     \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/6ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/7ro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/8ro.jpg}
     \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/9ro.jpg}
     
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Aro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Bro.jpg}      \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Cro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Dro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Ero.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Fro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Gro.jpg} 
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Hro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/I1.jpg}

    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Jro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Kro.jpg}      \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Lro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Mro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Nro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Oro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Pro.jpg} 
     \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Rro.jpg}

        \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Sro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Tro.jpg} 
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Uro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Vro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Wro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Xro.jpg} 
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Yro.jpg}
    \includegraphics[width=0.05\linewidth, height=2cm]{CharTemplates/Zro.jpg}
  \caption{Toate caracterele posibile pe o pl\u{a}cuț\u{a} din Rom\^{a}nia.}
  \label{fig:recunoastere_set_chars}
\end{figure}

Astfel, algoritmul de template matching calculeaz\u{a} un grad de asem\u{a}nare \^{i}ntre diferite regiuni ale fiec\u{a}rei imagini de intrare, adic\u{a} imaginile caracterelor, și imaginile template. Pentru m\u{a}surarea similarit\u{a}ții se pot folosi mai multe metode, cum ar fi:

\begin{itemize}
    \item Diferența absolut\u{a} medie (MAD): Calculeaz\u{a} media diferenței absolute dintre pixelii din șablon și cei din regiunea corespunz\u{a}toare a imaginii de intrare.
    \item Diferența p\u{a}tratic\u{a} medie (MSE): Calculeaz\u{a} media p\u{a}tratelor diferențelor dintre pixelii din șablon și cei din regiunea corespunz\u{a}toare a imaginii de intrare.
    \item Coeficientul de corelație: M\u{a}soar\u{a} gradul de corelație \^{i}ntre intensit\u{a}țile pixelilor din șablon și cele din regiunea corespunz\u{a}toare a imaginii de intrare.
\end{itemize}

Pentru m\u{a}surarea similarit\u{a}ții \^{i}n cazul recunoașterii de caractere, se va folosi metrica coeficientul de corelație normalizat, av\^{a}nd urm\u{a}toarea formul\u{a}, unde A și B sunt matricile de pixeli corespunz\u{a}toare imaginii template și a regiunii imaginii de intrare, A'(x,y) și B'(x,y) sunt valorile normalizate ale intensit\u{a}ților pixelilor din matricele A și B, \ensuremath{\bar{A}} și \ensuremath{\bar{B}} reprezint\u{a} mediile pixelilor din matricile A și B \cite{templatematching}.

\begin{equation}
R(A, B) = \frac{\sum_{x,y} (A'(x,y) - \bar{A})(B'(x,y) - \bar{B})}{\sqrt{\sum_{x,y} (A'(x,y) - \bar{A})^2 \sum_{x,y} (B'(x,y) - \bar{B})^2}}
\end{equation}

Pentru identificarea unui caracter specific dintr-o imagine, se va aplica algoritmul de template matching pentru imaginea caracterului respectiv pe toate imaginile template ale tuturor caracterelor posibile ce pot fi pe o pl\u{a}cuț\u{a} de \^{i}nmatriculare din Romania. Dup\u{a} aceea, caracterul ce prezint\u{a} cea mai mare asem\u{a}nare cu imaginea de intrare va fi considerat, cu excepția cazului \^{i}n care valoarea maxim\u{a} a asem\u{a}n\u{a}rii nu dep\u{a}șește 0.40 (40\%), caz \^{i}n care imaginea de intrare va fi ignorat\u{a} și niciun caracter nu va fi returnat.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{ImaginiPlacute/BV71AXE_undist.jpg}
        \caption{Text: BV 71 AXE}
        \label{fig:img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{ImaginiPlacute/18.jpg}
        \caption{Text: 8V 24 NSC}
        \label{fig:img2}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{ImaginiPlacute/BV75XXL_undist.jpg}
        \caption{Text: BV 75 XXL}
        \label{fig:img3}
    \end{subfigure}
    \caption{Rezultatele recunoașterii pe diferite pl\u{a}cuțe.}
    \label{fig:rezultate_recunoastere_text}
\end{figure}

\^{I}n final, algoritmul prezentat s-a dovedit a fi eficient și precis \^{i}n recunoașterea caracterelor de pe pl\u{a}cuțele de \^{i}nmatriculare ale mașinilor, obțin\^{a}nd o acuratețe final\u{a} de 89.30\% pe caracterele recunoscute, și de 74.46\% pe numerele de \^{i}nmatriculare recunoscute \^{i}n totalitate, majoritatea greșelilor fiind pentru caracterul "B", care este confundat uneori cu caracterul "8", așa cum se poate observa și \^{i}n figura \ref{fig:rezultate_recunoastere_text} (b), caracterul "1", care este confundat cu caracterul "I", și caracterul "O", care este confundat cu caracterul "0". Totuși, \^{i}n aproape toate cazurile \^{i}n care au avut loc aceste greșeli, s-a observat c\u{a} distorsiunile geometrice nu au fost corectate \^{i}n totalitate iar unele caractere sunt \^{i}n continuare mai mult sau mai puțin \^{i}nclinate, asem\u{a}n\u{a}tor figurii \ref{fig:rezultate_recunoastere_text} (b).
%țș

\newpage

\section{Modelarea entităților}

Modelarea entit\u{a}ților reprezint\u{a} o etap\u{a} fundamental\u{a} \^{i}n dezvoltarea unei aplicații software ce implic\u{a} definirea și organizarea structurilor de date necesare pentru funcționarea corect\u{a} a aplicației. Primul pas \^{i}n acest proces de modelare a entit\u{a}ților este identificarea entit\u{a}ților principale ale sistemului, fie c\u{a} acestea sunt obiecte, concepte sau componente semnificative. De exemplu, \^{i}n aplicațiile ce compun sistemul de monitorizare și gestionare a unei parc\u{a}ri, entit\u{a}țile importante sunt "Camera", "Session, "ParkingSession" și "Users" 

Odat\u{a} ce entit\u{a}țile au fost identificate, urm\u{a}torul pas const\u{a} \^{i}n definirea atributelor asociate fiec\u{a}rei entit\u{a}ți. Atributele reprezint\u{a} informațiile specifice pe care entitatea le are \^{i}n posesie. Pentru entitatea "Users", de exemplu, atributele pot include un num\u{a}r de identificare (ID), num\u{a}rul de \^{i}nmatriculare (username) și o parol\u{a}.

Dup\u{a} definirea atributelor, urmeaz\u{a} definirea relațiilor dintre entit\u{a}ți. Acestea reprezint\u{a} modul \^{i}n care o entitate este conectat\u{a} și interacționeaz\u{a} cu o alt\u{a} entitate. \^{I}n cazul sistemului de monitorizare și gesiune a unei parc\u{a}ri, o relație important\u{a} este \^{i}ntre "Session" și "ParkingSession", \^{i}nsemn\^{a}nd c\u{a} \^{i}ntr-o sesiune principal\u{a} pot exista mai multe "sesiuni de parcare", mai exact, un șofer poate parca pe mai multe locuri de parcare (ParkingSession) \^{i}n cadrul unei singure sesiuni (Session).

Procesul de modelare a entit\u{a}ților este adesea iterativ, iar acesta poate suferi modific\u{a}ri pe parcurs, \^{i}n funcție de evoluția cerințelor și a specificațiilor. Prin urmare, este necesar ca acesta s\u{a} fie deschis la ajust\u{a}ri.

\^{I}n continuare vor fi prezentate toate entit\u{a}țile și atributele sale, al\u{a}turi de o descriere detaliat\u{a} a acestora. Lista entit\u{a}ților este urm\u{a}toarea: "Camera", "CameraType", "CameraKey", "Session", "ParkingSession", "ParkingSpace", "Users" și "Reports"

\subsection{Entitatea "Camera"}

Entitatea \textbf{"Camera"} reprezint\u{a} tabela \^{i}n care se stocheaz\u{a} toate informațiile legate despre o camer\u{a} video a parc\u{a}rii. Aceste camere video sunt amplasate strategic \^{i}n diverse locații din parcarea auto, precum intrarea, ieșirea și alte zone din parcare de unde se poate observa mișcarea autovehiculelor ce parcheaz\u{a} pe anumite locuri de parcare, pentru a captura imagini ale acestora \^{i}n vederea detect\u{a}rii și recunoașterii numerelor de \^{i}nmatriculare ale autovehiculelor.
%țș

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare a camerei video \^{i}n baza de date.  \\
\hline
\textbf{camera\_type\_id} & int & Num\u{a}rul unic de identificare a tipului dorit pentru camera video.  \\
\hline
\textbf{location} & String & Path-ul c\u{a}tre camera video sau index-ul acesteia. \\
\hline
\textbf{name} & String & Numele atribuit camerei video. \\
\hline
\end{tabular}
\caption{Entitatea "Camera"}
\end{table}

Pentru ad\u{a}ugarea unei \^{i}nregistr\u{a}ri tabelei "Camera", vor fi necesare doar ultimele trei atribute, "camera\_type\_id", "location" și "name". Primul atribut, ID, se va autogenera. Cel de-al doilea atribut, "camera\_type\_id", va fi un num\u{a}r \^{i}ntre 1 și 3 ce va reprezenta tipul camerei dorit, mai exact, 1 pentru tipul ENTRANCE, 2 pentru tipul EXIT și 3 pentru tipul PARKING. Atributul "location" poate fi at\^{a}t path-ul c\u{a}tre device-ul sau video-ul ce reprezint\u{a} o camer\u{a} video (de exemplu, "/dev/video0"), sau index-ul acesteia (de exemplu, "0"). Atunci c\^{a}nd vor fi citite datele camerelor video \^{i}n aplicație, se va verifica dac\u{a} "location" este un path sau un index. \^{I}n final, atributul "name" reprezint\u{a} numele atribuit camerei video și deși nu este obligatoriu s\u{a} fie unic, se recomand\u{a} totuși evitarea numelor duplicate pentru evitarea greșelilor \^{i}n cazul modific\u{a}rii acestora. Dac\u{a} se merge pentru varianta numelor duplicate, atunci modificarea camerelor video va necesita o atenție sporit\u{a}, utilizatorul asigur\^{a}ndu-se c\u{a} modific\u{a} camera corect\u{a} pe baza ID-ului acesteia. 

\subsection{Entitatea "CameraType"}

Entitatea \textbf{"CameraType"} reprezint\u{a} o tabel\u{a} ce stocheaz\u{a} toate tipurile existente ce pot fi atribuite unei camere video. Aceasta tabel\u{a} este modificat\u{a}, validat\u{a} și corectat\u{a} automat la rularea aplicației principale, implementat\u{a} \^{i}n C++. 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare a unui tip de camer\u{a} \^{i}n baza de date.  \\
\hline
\textbf{type} & String & Numele tipului de camer\u{a} video.  \\
\hline
\end{tabular}
\caption{Entitatea "CameraType"}
\end{table}

Astfel, la rularea aplicației se vor verifica toate \^{i}nregistr\u{a}rile din aceast\u{a} tabel\u{a} iar \^{i}n cazul \^{i}n care acestea corespund celor implicite, ele vor fi șterse și ad\u{a}ugate din nou. 

Dac\u{a} dintr-un motivul sau altul se dorește ad\u{a}ugarea unui nou tip de camer\u{a} video, atunci va fi necesar\u{a} modificarea acestei verific\u{a}ri la rularea aplicației și a ad\u{a}ug\u{a}rii unei noi valori \^{i}n obiectul de tip enum ce reprezint\u{a} tipul camerei video. Acest enum se afl\u{a} \^{i}n fișierul header destinat acestei entit\u{a}ți ("CameraType.h") aflat \^{i}n cadrul componentei Model al arhitecturii MVC, urmat\u{a} de layer-ul "Entities" (Model) al arhitecturii pe trei nivele pentru baza de date. Mai departe, se va ad\u{a}uga funcționalitatea dorit\u{a} la declanșarea acțiunii pentru acest tip de camer\u{a} video \^{i}n clasa ActionManagement. Acțiunea reprezint\u{a} felul \^{i}n care imaginea capturat\u{a} de la camera video și num\u{a}rul de \^{i}nmatriculare recunoscut sunt manipulate \^{i}n funcție de tipul camerei video. 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{id}  & \textbf{type} \\
\hline
1 & ENTRANCE  \\
\hline
2 & EXIT \\
\hline
3 & PARKING \\
\hline
\end{tabular}
\caption{\^{I}nregistr\u{a}rile implicite ale entit\u{a}ții "CameraType"}
\end{table}

\subsection{Entitatea "CameraKey"}

Entitatea \textbf{"CameraKey"} reprezint\u{a} tabela \^{i}n care sunt stocate tastele folosite pentru declanșarea acțiunii unei camere video, ca de exemplu, la intrarea \^{i}n parcare unde camera video va prelua un frame pe care \^{i}l va folosi pentru detectarea și recunoașterea num\u{a}rului de \^{i}nmatriculare al autovehiculului prezent. O tasta (key) poate fi orice liter\u{a} de la A la Z, reprezentat\u{a} ca valoare numeric\u{a} \^{i}n cod ASCII, și este unic\u{a} pentru fiecare camer\u{a} video \^{i}n parte.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{camera\_id} & int & Num\u{a}rul unic de identificare a unei camerei video.  \\
\hline
\textbf{key} & int & Valoarea numeric\u{a} asociat\u{a} tastei alese \^{i}n codul ASCII.  \\
\hline
\end{tabular}
\caption{Entitatea "CameraKey"}
\end{table}

\subsection{Entitatea "Session"}

Entitatea \textbf{"Session"} reprezint\u{a} tabela \^{i}n care sunt stocate toate sesiunile șoferilor. Sesiunea \^{i}n acest context se refer\u{a} la intervalul de timp \^{i}n care un șofer utilizeaz\u{a} parcarea. Aceast\u{a} sesiune \^{i}ncepe \^{i}n momentul \^{i}n care șoferul intr\u{a} \^{i}n parcare și se \^{i}ncheie atunci c\^{a}nd acesta o p\u{a}r\u{a}sește.

O \^{i}nregistrare a unei sesiuni se creaz\u{a} atunci c\^{a}nd un șofer va acționa un buton sau o tast\u{a} atribuit\u{a} camerei video a intr\u{a}rii respective. Dac\u{a} num\u{a}rul de \^{i}nmatriculare al autovehiculului este recunoscut cu succes, atunci acesta va fi inclus \^{i}n atributul "license\_plate" al sesiunii. Pe l\^{a}ng\u{a} num\u{a}rul de \^{i}nmatriculare și num\u{a}rul unic de identificare al sesiunii ("id"), va exista un alt num\u{a}r unic de identificare al sesiunii, mai complex, numit SecretID, ce este compus dintr-un șir de numere, urmat de text-ul pl\u{a}cuței de \^{i}nmatriculare ce a fost recunoscut. Acest "SecretID" va fi folosit pentru crearea unui cont de utilizator pe aplicația web și pentru ieșirea forțat\u{a} din parcare pentru cazul \^{i}n care num\u{a}rul de \^{i}nmatriculare nu a putut fi detectat la intrare sau a fost detectat la intrare, dar nu mai poate fi detectat la ieșire.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare al sesiunii.  \\
\hline
\textbf{license\_plate} & String & Num\u{a}rul de \^{i}nmatriculare detectat.  \\
\hline
\textbf{entrance\_time} & timestamp & Data și ora \^{i}nceperii sesiunii.  \\
\hline
\textbf{exit\_time} & timestamp & Data și ora \^{i}ncheierii sesiunii.  \\
\hline
\textbf{secret\_id} & String & Num\u{a}rul special de identificare al sesiunii, oferit șoferilor la intrare.  \\
\hline
\end{tabular}
\caption{Entitatea "Session"}
\end{table}

\subsection{Entitatea "ParkingSpace"}

Entitatea \textbf{"ParkingSpace"} este responsabil\u{a} pentru stocarea informațiilor pentru fiecare loc de parcare definit, pe care s\u{a} se realizeze detecția num\u{a}rului de \^{i}nmatriculare. Se consider\u{a} c\u{a} o camer\u{a} video de tip PARKING este static\u{a} și astfel se pot crea zone delimitatoare pentru fiecare loc de parcare disponibil din c\^{a}mpul vizual al camerei video respective. Av\^{a}nd aceast\u{a} zon\u{a} delimitatoare pentru un loc de parcare dar și un nume atribuit acestuia (cum ar fi, M23, unde M reprezint\u{a} r\^{a}ndul și 23 locul de parcare de pe r\^{a}ndul respectiv), se poate realiza detecția pe aceast\u{a} zon\u{a} iar ca urmare, șoferii vor putea vedea \^{i}n cadrul aplicației web, locul de parcare pe care și-au parcat autovehiculul. De asemenea, cu ajutorul acestei entit\u{a}ți se pot realiza și diferite statistici precum gradul de ocupare al parc\u{a}rii, locurile de parcare cele mai des ocupate și altele.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare al locului de parcare.  \\
\hline
\textbf{camera\_id} & int & Num\u{a}rul unic de identificare a unei camerei video. \\
\hline
\textbf{name} & String & Numele atribuit locului de parcare.  \\
\hline
\textbf{x1} & int & Coordonata X a primului punct ce reprezint\u{a} zona delimitatoare.  \\
\hline
\textbf{y1} & int & Coordonata Y a primului punct ce reprezint\u{a} zona delimitatoare.  \\
\hline
\textbf{x2} & int & Coordonata X a celui de-al doilea punct ce reprezint\u{a} zona delimitatoare. \\
\hline
\textbf{y2} & int & Coordonata Y a celui de-al doilea punct ce reprezint\u{a} zona delimitatoare.  \\
\hline
\end{tabular}
\caption{Entitatea "ParkingSpace"}
\end{table}

\subsection{Entitatea "ParkingSession"}

Entitatea \textbf{"ParkingSession"} este asem\u{a}n\u{a}toare entit\u{a}ții "Session", ambele referindu-se la un interval de timp \^{i}n care șoferul utilizeaz\u{a} un lucru anume. \^{I}n cazul entit\u{a}ții "Session", aceasta se referea la intervalul de timp \^{i}n care conduc\u{a}torul autovehiculului utilizeaz\u{a} parcarea, pe c\^{a}nd \^{i}n cazul entit\u{a}ții \textbf{"ParkingSession"}, aceasta se refer\u{a} la intervalul de timp \^{i}n care un autovehicul a c\u{a}rui num\u{a}r a fost detectat pe unul din locurile de parcare definite se afl\u{a} parcat pe acesta.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare a sesiunii de parcare.  \\
\hline
\textbf{session\_id} & int & Num\u{a}rul unic de identificare a unei sesiuni. \\
\hline
\textbf{parking\_space\_id} & int & Num\u{a}rul unic de identificare a unui loc de parcare.  \\
\hline
\textbf{start\_time} & timestamp & Data și ora la care a fost detectat autovehiculul pe locul de parcare.  \\
\hline
\textbf{end\_time} & timestamp & Data și ora la care autovehiculul a p\u{a}r\u{a}sit locul de parcare. \\
\hline
\end{tabular}
\caption{Entitatea "ParkingSpace"}
\end{table}

Atunci c\^{a}nd un num\u{a}r de \^{i}nmatriculare este detectat pe unul din locurile de parcare, se verific\u{a} s\u{a} nu existe deja o sesiune de parcare (ParkingSession) pentru acest loc, și dac\u{a} nu exist\u{a}, se consider\u{a} ca autovehiculul abia a parcat și se creeaz\u{a} o sesiune de parcare nou\u{a}. De asemenea, dac\u{a} pentru num\u{a}rul de \^{i}nmatriculare respectiv a existat o sesiune de parcare dar pentru alt loc, atunci sesiunea trecut\u{a} va fi considerat\u{a} \^{i}ncheiat\u{a}. Sesiunea de parcare nou\u{a} va include informații precum sesiunea curent\u{a} a num\u{a}rului de \^{i}nmatriculare, data și ora \^{i}nceperii și \^{i}ncet\u{a}rii stațion\u{a}rii și locul de parcare pe care a fost detectat și va fi creat\u{a} doar dac\u{a} se gasește o sesiune principal\u{a} (Session) pentru num\u{a}rul de \^{i}nmatriculare detectat.

\subsection{Entitatea "Users"}

Entitatea "Users" este destinat\u{a} doar aplicației web și reprezint\u{a} un cont al unui utilizator. Așa cum a fost menționat anterior, utilizatorii parc\u{a}rii au posibilitatea cre\u{a}rii unui cont de utilizator pe aplicația web unde \^{i}și vor putea vizualiza toate sesiunile, locurile pe care au parcat \^{i}n cadrul acestora, vor putea adresa \^{i}ntreb\u{a}ri și vor putea crea rapoarte \^{i}n cazul \^{i}nt\^{a}mpin\u{a}rii unei probleme. Aceast\u{a} entitate va stoca informațiile unui utilizator, mai precis username-ul acestuia și parola sa. Parolele stocate \^{i}n baza de date sunt criptate folosind BCrypt.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare al contului de utilizator.  \\
\hline
\textbf{license\_plate} & String & Username-ul utilizatorului (num\u{a}rul de \^{i}nmatriculare). \\
\hline
\textbf{password} & String & Parola utilizatorului, criptat\u{a}.  \\
\hline
\end{tabular}
\caption{Entitatea "Users"}
\end{table}

\subsection{Entitatea "Reports"}

Entitatea "Reports" este destinat\u{a} aplicației web și este utilizat\u{a} pentru \^{i}nregistrarea și gestionarea rapoartelor referitoare la problemele \^{i}nt\^{a}mpinate \^{i}n cadrul parc\u{a}rii. Aceasta conține mai multe câmpuri care descriu detaliat fiecare raport în parte. Fiecare raport este asociat unei sesiuni, identificat\u{a} prin c\^{a}mpul "session\_id". Utilizatorii pot crea un raport direct de pe pagina principal\u{a} a aplicației web doar dac\u{a} num\u{a}rul lor de \^{i}nmatriculare a fost detectat pentru sesiune respectiv\u{a}. Lista rapoartelor poate fi vizualizat\u{a} numai din contul special de administrator.
%țș

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Nume c\^{a}mp}  & \textbf{Tip c\^{a}mp} & \textbf{Descriere} \\
\hline
\textbf{id} & int & Num\u{a}rul unic de identificare al raportului.  \\
\hline
\textbf{session\_id} & int & Num\u{a}rul unic de identificare a sesiunii.  \\
\hline
\textbf{reporter} & String & Num\u{a}rul de \^{i}nmatriculare a autovehiculului care a raportat. \\
\hline
\textbf{suspect} & String & Num\u{a}rul de \^{i}nmatriculare a autovehiculului raportat.  \\
\hline
\textbf{time\_period} & String & Perioada \^{i}nt\^{a}mpin\u{a}rii problemei, oferit\u{a} de utilizator. \\
\hline
\textbf{contact} & String & Informațiile de contact ale persoanei care a raportat.  \\
\hline
\textbf{details} & String & Detaliile problemei. \\
\hline
\textbf{opened} & boolean & Statusul raportului.  \\
\hline
\end{tabular}
\caption{Entitatea "Reports"}
\end{table}

\newpage

\section{Prezentarea aplicațiilor}

\^{I}n cadrul acestei lucr\u{a}ri, vor fi prezentate dou\u{a} aplicații legate \^{i}ntre ele ce se ocup\u{a} de monitorizarea și gestionarea parc\u{a}rii: una dezvoltat\u{a} \^{i}n limbajul de programare C++ și cealalt\u{a} \^{i}n Java.

Prima aplicație este o implementare \^{i}n C++ a unui sistem de monitorizare și gestionare a unei parc\u{a}ri ce se ocup\u{a} de configurarea camerelor video din interiorul parc\u{a}rii și a locurilor de parcare, de detecția și recunoașterea numerelor de pe pl\u{a}cuțele de \^{i}nmatriculare ale mașinilor și de salvarea datelor legate de fiecare mașin\u{a} și camera video. 

\^{I}n al doilea r\^{a}nd, se va adresa o alt\u{a} perspectiv\u{a} prin prezentarea unei aplicații web implementate \^{i}n Java, care permite utilizatorilor s\u{a} vizualizeze diferite detalii pentru num\u{a}rul de \^{i}nmatriculare cu care și-au creat contul pe aplicație, precum data și ora \^{i}n care a intrat \^{i}n parcare, timpul r\u{a}mas, locul de parcare pe care a parcat, etc. Aceast\u{a} aplicație web ofer\u{a} o interfaț\u{a} prietenoas\u{a} și accesibil\u{a}, permiț\^{a}nd utilizatorilor s\u{a} vizualizeze toate detaliile legate de sesiunea de parcare curent\u{a}, fara a fi nevoie de instalarea și rularea unui software suplimentar pe dispozitivele acestora.

\subsection{Aplicația C++}

\subsubsection{Arhitectura MVC}

\^{I}n implementare aplicației C++ s-a folosit arhitectura Model-View-Controller (MVC), care este un model de proiectare arhitectural a aplicațiilor software care separ\u{a} componentele sale \^{i}n trei p\u{a}rți distincte: Model, View și Controller. Aceast\u{a} separare permite dezvoltatorilor s\u{a} \^{i}și organizeze mai eficient codul și s\u{a} \^{i}și mențin\u{a} aplicațiile mai ușor de \^{i}ntreținut și de extins.

Modelul reprezint\u{a} componenta care gestioneaz\u{a} datele și logica aplicației. Aici sunt definite clasele și funcțiile care permit manipularea acestora. Modelul nu este conștient de interfața utilizatorului sau de cum datele sunt prezentate pe aceasta, ci se concentreaz\u{a} exclusiv pe gestionarea informațiilor și a logicii asociate.

View-ul este responsabil cu prezentarea datelor utilizatorului. Aceasta reprezint\u{a} interfața utilizatorului, care poate fi o interfaț\u{a} grafic\u{a}, o pagin\u{a} web sau orice alt\u{a} form\u{a} de prezentare a informațiilor. Acesta primește datele de la model și le afișeaz\u{a} \^{i}ntr-o form\u{a} ușor de \^{i}nțeles pentru utilizatori.

Controller-ul este intermediar între Model și View. El primește input-ul de la utilizator prin intermediul interfeței utilizatorului și decide cum s\u{a} proceseze aceste input-uri. Mai departe acesta interacționeaz\u{a} cu Model-ul pentru a obține datele necesare și le transmite apoi către componenta View pentru afișare.

Separarea clar\u{a} a problemelor \^{i}ntre diferitele componente este unul din avantajele principale ale folosirii arhitecturii MVC. Aceast\u{a} separare permite lucrarea \^{i}n mod independent la fiecare component\u{a} \^{i}n parte, ceea ce faciliteaz\u{a} extinderea, testarea și \^{i}ntreținerea aplicației. De exemplu, schimbarea modului \^{i}n care datele sunt prezentate utilizatorului \^{i}n interfața grafic\u{a} nu afecteaz\u{a} deloc logica din spate, deoarece aceasta este gestionat\u{a} de componenta Model \cite{mvc}.

Astfel, av\^{a}nd clase dedicate bazei de date ce se ocup\u{a} cu manipularea informațiilor din aceasta, clase ce se ocup\u{a} cu prelucrarea imaginilor preluate din camerele video definite și ulterior cu detectarea și recunoașterea caracterelor din num\u{a}rul de \^{i}nmatriculare al mașinii, și clase dedicate interfeței grafice, arhitectura MVC a fost cea mai potrivit\u{a} alegere pentru dezvoltarea acestei aplicații, facilit\^{a}nd organizarea și gestionarea codului.

\subsubsection{Arhitectura pe trei nivele pentru baza de date}

\^{I}n cadrul componentei Model din arhitectura MVC se afl\u{a} și implementarea claselor necesare pentru manipularea datelor din baza de date, iar aceasta este, la r\^{a}ndul ei, implementat\u{a} de asemenea pe mai multe nivele. Astfel, arhitectura pe trei nivele este o modalitate comun\u{a} pentru organizarea codului și pentru separarea clar\u{a} dintre manipularea datelor, logic\u{a} și interfața utilizatorului. Cele trei nivele din cadrul arhitecturii sunt Data Access, Business Logic și Entity \cite{threelayer}.

\^{I}n primul r\^{a}nd, nivelul Data Access cuprinde clasele și funcțiile ce se ocup\u{a} direct de interacțiunea cu baza de date, fiind cel mai apropiat nivel faț\u{a} de aceasta. Clasele și funcțiile includ operații CRUD, adic\u{a} creare, citire, actualizare și ștergere a datelor. Pentru conectarea și interacțiunea cu baza de date s-au folosit clasele specifice din biblioteca Qt, de exemplu, QtSql, QtSqlDatabase, QtSqlQuery.

\^{I}n al doilea r\^{a}nd, nivelul Business Logic include logica aplicației, mai precis modul \^{i}n care datele sunt procesate și utilizate \^{i}n cadrul aplicației. Acest nivel cuprinde clasele și funcțiile care definesc operațiile și anumite reguli, precum valid\u{a}ri, calcule sau transform\u{a}ri, folosind datele primite de la nivelul DataAccess.

\^{I}n final, nivelul Entity cuprinde clasele ce definesc structura datelor utilizate \^{i}n aplicație și sunt utilizate de c\u{a}tre nivelul Business Logic pentru manipularea datelor \^{i}n conformitate cu regulile și operațiile definite și de c\u{a}tre nivelul Data Access pentru \^{i}nteracțiunea cu baza de date.

Prin utilizarea acestei arhitecturi pe trei nivele, se realizeaz\u{a} o separare clar\u{a} a responsabilitaților din cadrul aplicației, favoriz\^{a}nd astfel un cod mai ușor de \^{i}nțeles, de testat și de \^{i}ntreținut.

\subsubsection{Realizarea interfeței grafice}

Rolul interfeței grafice este acela de a oferi utilizatorului un mijloc eficient și intuitiv pentru interacțiunea cu funcționalit\u{a}țile oferite. Toate informațiile și actiunile disponibile \^{i}n interfaț\u{a} sunt prezentate folosind anumite texte sugestive pentru realizarea fiec\u{a}rei componente.
%țș

Pentru realizarea interfeței grafice a proiectului s-a folosit mediul de dezvoltare Qt. Crearea și utilizarea unui GUI se poate realiza cu ușurinț\u{a} folosind cele dou\u{a} instrumente oferite de Qt, și anume, Qt Designer și Qt Creator. Diferența dintre cele dou\u{a} instrumente este c\u{a} Qt Creator este un mediu de dezvoltare integrat pentru dezvoltarea aplicațiilor Qt, pe c\^{a}nd Qt Designer se ocup\u{a}, așa cum reiese și din denumirea sa, doar cu proiectarea interfeței grafice.

Interfața acestei aplicații a fost creat\u{a} utiliz\^{a}nd instrumentul Qt Designer. Astfel, \^{i}n urma cre\u{a}rii unui GUI, se obține un fișier cu extensia "*.ui", ce poate fi integrat cu ușurinț\u{a} \^{i}n orice aplicație. \^{I}n continuare, se vor prezenta c\^{a}teva componente de baz\u{a}, numite widgets, ce sunt prezente pe interfața grafic\u{a} a aplicației.

Fereastra principal\u{a} care ofer\u{a} un cadru pentru ad\u{a}ugarea tuturor elementelor necesare proiect\u{a}rii unui GUI se numește \textbf{QMainWindow}.

Obiectele din interfața grafic\u{a} sunt moștenite de clasa \textbf{QWidget}. Este posibil ca prin intermediul acesteia s\u{a} se poat\u{a} primi anumite evenimente de la tastatur\u{a}, precum ap\u{a}sarea unei taste, și mouse, precum un clic, c\u{a}rora s\u{a} le r\u{a}spund\u{a} prin indeplinirea unor acțiuni.

Sistemul de layout-uri al Qt-ului se ocup\u{a} de aranjarea automat\u{a} a tuturor widget-urilor copil \^{i}n zona destinat\u{a} unui widget p\u{a}rinte, astfel \^{i}nc\^{a}t tot spațiul disponibil s\u{a} fie umplut. Rolul layout-urilor este de a redimensiona și poziționa elementele din interfața grafic\u{a} \^{i}n momentul \^{i}n care dimensiunea a schimbat\u{a}, asigur\^{a}nd astfel rearanjarea constant\u{a} a widget-urilor. QGridLayout este o alt\u{a} clas\u{a} din Qt ce se ocup\u{a} de aranjarea elementelor din interfaț\u{a} \^{i}ntr-un tablou bidimensional, acestea av\^{a}nd posibilitatea de a ocupa mai multe celule. De regul\u{a}, la ad\u{a}ugarea unui element \^{i}n QGridLayout, se va atribui o anumit\u{a} dimensiune pentru ocuparea spațiului disponibil \^{i}n funcție de restul componentelor ce urmeaz\u{a} a fi ad\u{a}ugate \cite{widgets}.

\textbf{QLabel} este un element ce permite afișarea de texte, imagini sau video-uri \^{i}n interfața grafic\u{a}. Acestuia i se pot ad\u{a}uga diferite conținuturi astfel: \^{i}n cazul text-ului, se va utiliza funcția \textbf{setText()}, care necesit\u{a} un parametru de tip \textbf{QString}, iar \^{i}n cazul afiș\u{a}rii sau manipul\u{a}rii unei imagini se va utiliza \textbf{setPixmap()}, ce necesit\u{a} un parametru de tip \textbf{QPixmap}. \^{I}n aceast\u{a} aplicație se vor utiliza aceste dou\u{a} elemente chiar din prima pagin\u{a} a acesteia, adic\u{a} pagina principal\u{a}, unde vor exista dou\u{a} chenare pe care se vor afișa imagini preluate de la camerele video, iar deasupra lor, vor exista dou\u{a} QLabel-uri ce conțin texte. Avantajul elementului QPixmap este c\u{a} acesta are proprietatea de a nu umple memoria atunci c\^{a}nd imaginea este schimbat\u{a}. Astfel, programul este optim și se pot realiza oric\^{a}te \^{i}nc\u{a}rc\u{a}ri de imagini \^{i}n cadrul unui QPixmap.

\textbf{QLineEdit} este elementul utilizat pentru crearea unui c\^{a}mp de text simplu unde utilizatorul poate introduce sau edita text.

\textbf{QComboBox} reprezint\u{a} un control de list\u{a} derulant\u{a} ce ofer\u{a} utilizatorului posibilitatea de a selecta una din mai multe opțiuni predefinite dintr-o list\u{a}.

\textbf{QListWidget} este un element ce ofer\u{a} o list\u{a} afișat\u{a} \^{i}n interfața grafic\u{a}, unde fiecare element din list\u{a} poate fi selectat. Poate fi utilizat\u{a} pentru afișarea unor liste simple de elemente, cu sau f\u{a}r\u{a} posibilitatea de a le edita. \^{I}n cadrul aplicației, acest element este folosit pentru a afișa o list\u{a} de elemente, mai precis camere video, pe care utilizatorul le poate selecta pentru a putea vizualiza/completa automat toate detaliile despre aceasta, ușur\^{a}ndu-i astfel munca.

\textbf{QMenuBar} este elemente care conține o bar\u{a} de meniuri. \^{I}n aplicația prezentat\u{a} se va folosi un astfel de meniu pentru a oferi mai mult loc celor dou\u{a} chenare \^{i}n care se vor afișa fluxuri video. 

\textbf{QMenu} creeaz\u{a} un meniu ce poate fi utilizat \^{i}n interiorul b\u{a}rii de meniu, mai precis \^{i}ntr-un QMenuBar. Acest meniu poate fi de dou\u{a} tipuri: de sine st\u{a}t\u{a}tor sau derulant (afișat \^{i}n jos). \^{I}n cadrul aplicației vor exista trei meniuri de tip pull-down.

\^{I}n cadrul aplicațiilor, multe dintre comenzi sunt apelate prin intermediul meniurilor, butoanelor sau a comenzilor rapide de la tastatur\u{a}. \textbf{QAction} poate conține at\^{a}t o comand\u{a} rapid\u{a}, c\^{a}t și un text sau o pictogram\u{a}. Odat\u{a} cu ad\u{a}ugarea unui QMenu, se va ad\u{a}uga implicit și un QAction iar aceast\u{a} acțiune trebuie conectat\u{a} neap\u{a}rat la un slot care o va efectua.

Qt ofer\u{a} și o metod\u{a} de comunicare bidirecțional\u{a} prin utilizarea semnalelor și a sloturilor, cunoscut\u{a} sub numele de tehnica de apelare invers\u{a}. \textbf{Semnalul} (signal) este emis mereu c\^{a}nd are loc un eveniment iar widget-urile din Qt au mai multe semnale predefinite, precum semnalul declanșat (triggered) care este și corespunz\u{a}tor pentru QAction și este activat la fiecare conexiune a unei acțiuni cu un slot corespunz\u{a}tor. Qt ofer\u{a} de asemenea posibilitatea ad\u{a}ug\u{a}rii \^{i}n orice moment a semnalelor proprii. De exemplu, \^{i}n evenimentul creat \^{i}n proiect, atunci c\^{a}nd se face click cu mouse-ul pe imaginea emis\u{a} de camera video \^{i}n momentul definirii locurilor de parcare, se va emite un semnal ce este recepționat atunci c\^{a}nd se conecteaz\u{a} cu funcția corespunz\u{a}toare \^{i}ndeplinirii acțiunii. Un \textbf{Slot} este o funcție ce reprezint\u{a} raspunsul unui semnal. \^{I}n Qt exista slot-uri predefinite, ca de exemplu slot-ul close() ce este folosit \^{i}n cadrul proiectului și implic\u{a} \^{i}nchiderea interfaței grafice.

Av\^{a}nd toate elementele ce compun interfața grafic\u{a} din proiect prezentate, se poate trece la evidențierea funcționalit\u{a}ții acesteia.
%țș

\subsubsection{Camerele Video}

Pentru ca sistemul de monitorizare și gestionare a parc\u{a}rii s\u{a} funcționeze, sunt necesare cel puțin dou\u{a} camere video, una destinat\u{a} intr\u{a}rii \^{i}n parcare, și cealalt\u{a} destinat\u{a} ieșirii. Acest lucru este necesar pentru a putea detecta și recunoaște num\u{a}rul de \^{i}nmatriculare  \^{i}n vederea \^{i}nregistrarii autovehiculelor ce intr\u{a} și p\u{a}r\u{a}sesc parcarea. La alegerea administratorului parc\u{a}rii, se pot introduce și camere video destinate locurilor de parcare ce vor putea \^{i}nregistra mașinile ce au parcat pe un loc anume.

\^{I}n aplicația ce urmeaz\u{a} a fi prezentat\u{a} vor exista trei tipuri de camere video numite \textbf{ENTRANCE}, \textbf{EXIT} și \textbf{PARKING}, ce vor putea fi atribuite camerelor video configurate. Fiecare tip va avea ca urmare o "Acțiune" specific\u{a}. Acțiunea reprezint\u{a} felul \^{i}n care imaginea capturat\u{a} de la camera video și num\u{a}rul de \^{i}nmatriculare recunoscut sunt manipulate \^{i}n funcție de tipul camerei video.

Tipul \textbf{ENTRANCE} se refer\u{a} la camerele video destinate intr\u{a}rii \^{i}n parcare și pot fi oric\^{a}te la num\u{a}r. Spre deosebire de tipul \textbf{PARKING}, aceasta necesit\u{a} declanșarea acțiunii manual prin ap\u{a}sarea unui buton de c\u{a}tre șofer, sau \^{i}n cazul test\u{a}rii, prin ap\u{a}sarea unei taste alese de administratorul parc\u{a}rii la configurarea camerei video, asem\u{a}nator parc\u{a}rilor din mall-uri, aeroporturi și așa mai departe. Acțiunea specific\u{a} acestui tip const\u{a} \^{i}n \^{i}ncercarea de a detecta și recunoaște num\u{a}rul de \^{i}nmatriculare a mașinii prezente \^{i}n fluxul video și de a \^{i}nregistra o nou\u{a} sesiune \^{i}n baza de date. Aceast\u{a} nou\u{a} sesiune va \^{i}nclude data și ora la care s-a realizat intrarea \^{i}n parcare, num\u{a}rul de \^{i}nmatriculare al mașinii dac\u{a} a fost recunoscut cu succes, iar dac\u{a} nu, atunci nu va exista niciun num\u{a}r, și un cod special, numit \textbf{SecretID}, care va putea fi folosit pentru crearea unui cont de utilizator pe pagina web a parc\u{a}rii, dar și pentru a putea p\u{a}r\u{a}si parcarea \^{i}n cazul eșecului la recunoașterea num\u{a}rului de \^{i}nmatriculare. Se va considera c\u{a} "Acțiunea" s-a terminat cu succes dac\u{a} s-a putut crea aceast\u{a} nou\u{a} sesiune. Motivul pentru care nu s-ar putea crea o nou\u{a} sesiune este pentru c\u{a} num\u{a}rul de \^{i}nmatriculare detectat se afl\u{a}, teoretic, \^{i}n interiorul parc\u{a}rii, caz \^{i}n care va fi nevoie de intervenția administratorului pentru a incheia vechea sesiune, lucrul realizat din meniul "Manage Entries" al aplicației. Utilizatorii vor putea vedea toate detaliile legate de sesiunile sale pe pagina web a parc\u{a}rii.

Tipul \textbf{PARKING} reprezint\u{a} camerele video destinate locurilor de parcare și vor cuprinde, \^{i}n general, trei sau patru locuri de parcare, \^{i}n funcție de calitatea acestora. La alegerea administratorului, acesta poate opta pentru renunțarea la acest tip de camere. La ad\u{a}ugarea unei camere video de acest tip va fi necesar\u{a} o configurare mai detaliat\u{a} ce va cuprinde și datele locurilor de parcare pe care aceasta le are \^{i}n vedere, ins\u{a} aceasta va fi prezentat\u{a} mai \^{i}n detaliu \^{i}ntr-un capitol viitor unde se va prezenta pagina special\u{a} pentru configurarea acesteia. Declanșarea acțiunii se face at\^{a}t automat, la un anumit interval de timp ce poate fi modificat, dar și manual prin ap\u{a}sarea unei taste de c\u{a}tre administrator. Acțiunea const\u{a} \^{i}n detectarea num\u{a}rului de \^{i}nmatriculare de pe fiecare loc de parcare configurat, fiec\u{a}rei camere video de acest tip. Dac\u{a} un num\u{a}r de \^{i}nmatriculare este detectat pe un loc de parcare A, se va verifica dac\u{a} exist\u{a} o sesiune activ\u{a} pe acesta iar \^{i}n caz afirmativ, se va crea o sesiune de parcare nou\u{a} pentru num\u{a}rul de \^{i}nmatriculare detectat pentru locul de parcare A și cu timpul curent, care va reprezenta timpul de \^{i}nceput al acesteia, pun\^{a}nd cap\u{a}t sesiunilor de parcare anterioare, dac\u{a} este cazul. \^{I}ncheierea unei sesiuni de parcare se refer\u{a} la ad\u{a}ugarea unui timp final acesteia. Dac\u{a} niciun num\u{a}r de \^{i}nmatriculare nu a putut fi detectat sau dac\u{a} acesta a fost detectat \^{i}n parcare, dar nu și la intrare, adic\u{a} sesiunii curente nu \^{i}i este atribuit niciun num\u{a}r de \^{i}nmatriculare, atunci se va ignora locul curent de parcare și se va trece la verificarea urm\u{a}torului. Utilizatorul va putea vedea pe pagina web a parc\u{a}rii toate detaliile legate at\^{a}t de sesiunea curent\u{a}, c\^{a}t și de sesiunile trecute, precum data și ora la care a \^{i}ntrat/ieșit din parcare, dar și locurile de parcare pe care acesta a parcat, elimin\^{a}nd nevoia șoferilor de a ține minte locul pe care au parcat.
%țș

Tipul \textbf{EXIT} se refer\u{a} la camerele video destinate ieșirii din parcare și pot fi, de asemenea, oric\^{a}te la num\u{a}r. Declanșarea acțiunii se face tot prin ap\u{a}sarea unui buton, \^{i}ns\u{a} aceasta difer\u{a} faț\u{a} de tipul \textbf{ENTRANCE}. Spre deosebire de tipul ENTRANCE, care creeaz\u{a} o nou\u{a} sesiune, tipul EXIT actualizeaz\u{a} sesiunea curent\u{a} prin ad\u{a}ugarea timpului (data și or\u{a}) la care s-a realizat ieșirea din parcare. Dac\u{a} la intrare nu a putut fi detectat num\u{a}rul de \^{i}nmatriculare sau nu a fost g\u{a}sit\u{a} nicio sesiune curent\u{a} specific\u{a} num\u{a}rului detectat, atunci p\u{a}r\u{a}sirea parc\u{a}rii se va realiza prin introducerea \textbf{SecretID-ului} aferent. \^{I}n cazul \^{i}nt\^{a}mpin\u{a}rii unei probleme, șoferii vor putea crea o sesizare pe pagina web.

Tastele pentru declanșarea acțiunilor camerelor video se pot atribui at\^{a}t la configurarea camerei video, c\^{a}t și dup\u{a}, cu condiția ca acestea s\u{a} fie unice și s\u{a} fie orice liter\u{a} din alfabet, de la A la Z. Camerele video de tip \textbf{PARKING} nu necesit\u{a} neap\u{a}rat o tast\u{a} definit\u{a}, acțiunea pentru acestea fiind declanșat\u{a} automat. De asemenea, aceste taste pot fi schimbate \^{i}n orice moment din meniul "Manage Cameras". 

Pentru ca aplicația s\u{a} funcționeze, este necesar ca toate camerele video s\u{a} fie configurate corect, \^{i}n caz contrar, aplicația va intra \^{i}n "repair mode" p\^{a}n\u{a} c\^{a}nd problemele sunt rezolvate. De exemplu, dac\u{a} o camer\u{a} video este scoas\u{a} din funcțiune, dar nu și ștears\u{a} din meniul destinat administr\u{a}rii camerelor video, atunci aplicația nu va mai funcționa dec\^{a}t dup\u{a} ștergerea acesteia din lista camerelor.
%țș

\subsubsection{Pagina principal\u{a}}

La deschiderea aplicației se poate observa pagina principal\u{a} a acesteia, ce conține dou\u{a} chenare \^{i}n care se poate vizualiza fluxul video a unor camere video, la alegere, din interiorul parc\u{a}rii, un buton "Refresh" și o bar\u{a} de meniuri \^{i}n st\^{a}nga sus av\^{a}nd la r\^{a}ndul ei, meniurile \textbf{"Settings"}, \textbf{"Manage Cameras"} și \textbf{"Manage Entries"}.

Butonul din josul paginii, \textbf{"Refresh"}, este folosit pentru a actualiza camerele video din \^{i}ntreaga aplicație. Odat\u{a} acționat, toate camerele video existente vor fi actualizate al\u{a}turi de cele dou\u{a} chenare. Acest lucru este necesar de fiecare dat\u{a} c\^{a}nd o camer\u{a} video este ad\u{a}ugat\u{a}, ștears\u{a}, sau actualizat\u{a}. De exemplu, \^{i}n cazul \^{i}n care se dorește vizualizarea altor camere video \^{i}n cele dou\u{a} chenare, este necesar\u{a} alegerea unui camera slot pentru o camer\u{a} video specific\u{a} din meniul "Manage Cameras", urmat\u{a} de acționarea butonului "Refresh". De asemenea, \^{i}n cazul test\u{a}rii, unde se folosesc video-uri predefinite \^{i}n loc de o camer\u{a} video, la finalizarea acestora este necesar\u{a} ap\u{a}sarea butonului pentru ca video-urile s\u{a} \^{i}nceap\u{a} din nou.

Pentru realizarea unei acțiuni pentru o camer\u{a} video se va ap\u{a}sa tasta atribuit\u{a} acesteia, indiferent dac\u{a} camera video respectiv\u{a} se afl\u{a} sau nu pe unul dintre cele dou\u{a} chenare. Se pot realiza oric\^{a}te acțiuni pentru orice tip de camer\u{a} video, cu condiția ca aceasta s\u{a} fie funcțional\u{a} la acel moment.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.70\linewidth]{ImaginiAplicatii/PaginaPrincipala.jpg}
  \caption{Pagina principal\u{a} a aplicației C++.}
  \label{fig:aplicatie_pagina_principala}
\end{figure}

\subsubsection{Meniul "Manage Cameras"}

Meniul "Manage Cameras" se g\u{a}sește pe pagina principal\u{a} a aplicației, mai exact \^{i}n bara de meniuri aflat\u{a} \^{i}n susul paginii. Acționarea acestuia va deschide o list\u{a} de opțiuni ce țin de administrarea camerelor video din interiorul aplicației:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiAplicatii/MeniulManageCameras.jpg}
  \caption{Meniul "Manage Cameras".}
  \label{fig:aplicatie_meniul_manage_cameras}
\end{figure}

Administrarea camerelor video este cel mai important aspect \^{i}n configurarea sistemului de monitorizare și gestionare a parc\u{a}rii, acestea fiind responsabile pentru capturarea frame-urilor \^{i}n vederea detect\u{a}rii și recunoașterii numerelor de \^{i}nmatriculare ale autovehiculelor, iar acest meniu ofer\u{a} toate uneltele necesare pentru manipularea camerelor video.

\begin{itemize}
    \item Add - deschide o fereastr\u{a} unde utilizatorul va putea ad\u{a}uga o nou\u{a} camer\u{a} video.
    \item Remove - deschide o fereastr\u{a} unde utilizatorul va putea șterge o camer\u{a} video.
    \item Update - deschide o fereastr\u{a} unde utilizatorul va putea modifica detaliile camerelor video.
    \item Manage Parking Spaces - deschide o fereastr\u{a} unde utilizatorul va putea configura locurile de parcare pentru camerele video de tip \textbf{PARKING}.
\end{itemize}

Opțiunile "Add", "Remove" și "Update" vor deschide o nou\u{a} fereastr\u{a} numit\u{a} "Camera Management", destinat\u{a} ad\u{a}ug\u{a}rii, ștergerii și modific\u{a}rii camerelor video, care, \^{i}n funcție de alegerea utilizatorului, va avea diferite modific\u{a}ri. Aceast\u{a} fereastr\u{a} este explicat\u{a} \^{i}n detaliu \^{i}n capitolul urm\u{a}tor.

Pe de alt\u{a} parte, opțiunea "Manage Parking Spaces" va deschide o alt\u{a} fereastr\u{a}, total diferit\u{a} faț\u{a} de "Camera Management", ce este destinat\u{a} configur\u{a}rii locurilor de parcare pentru camerele video de tip \textbf{PARKING}.

\subsubsection{Pagina "Camera Management"}

Pagina "Camera Management" este destinat\u{a} configur\u{a}rii camerelor video, oferind posibilitatea utilizatorului de a ad\u{a}uga, șterge sau modifica camerele video cu ușurinț\u{a}. Aceasta este alc\u{a}tuit\u{a} din patru butoane, trei textbox-uri, dou\u{a} combobox-uri și o list\u{a} de widget-uri. Se poate observa c\u{a} aceast\u{a} pagin\u{a} este totuși \^{i}mp\u{a}rțit\u{a} \^{i}n dou\u{a} p\u{a}rți, una pentru detaliile camerei video, iar cealalt\u{a} pentru lista camerelor video.

Deschiderea acestei pagini (ferestre) se realizeaz\u{a} prin acționarea unuia din cele trei butoane ale meniului "Manage Cameras", denumite "Add", "Remove" și "Update". \^{I}n funcție de butonul acționat, pagina va fi deschis\u{a} \^{i}n modul de utilizare dorit, \^{i}nsemn\^{a}nd c\u{a} anumite widget-uri vor dezactivate iar butonul de confirmare, care va purta numele modului ales, va efectua operația necesar\u{a}, salv\^{a}nd modific\u{a}rile \^{i}n baza de date.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.60\linewidth]{ImaginiAplicatii/ManageCamerasAdd.jpg}
  \caption{Pagina "Camera Management".}
  \label{fig:aplicatie_pagina_camera_management}
\end{figure}

Prima parte a ferestrei, destinat\u{a} introducerii și afis\u{a}rii detaliilor camerelor video și pozitionat\u{a} \^{i}n partea st\^{a}ng\u{a}, conține urm\u{a}toarele elemente: 

\begin{itemize}
    \item ID (QLineEdit) - num\u{a}rul unic de identificare a unei camere video, nemodificabil indiferent de modul de utilizare \^{i}n care fereastra a fost deschis\u{a}.
    \item Path/Index (QLineEdit) - path-ul sau index-ul camerei video, necesar pentru deschiderea acesteia.
    \item Name (QLineEdit) - numele atribuit camerei video.
    \item Type (QComboBox) - tipul camerei video.
    \item Key (QComboBox) - tasta atribuit\u{a} camerei video pentru declanșarea acțiunii.
    \item Update (QPushButton) - buton pentru confirmarea operației, numele acestuia fiind identic cu operația dorit\u{a}.
    \item Run Test (QPushButton) - buton pentru testarea camerei video folosind detaliile din textbox-uri și combobox-uri.
\end{itemize}

\^{I}n tabelul de mai jos sunt toate elementele din prima parte a ferestrei și starea lor (activ, dac\u{a} acesta poate fi modificat, și inactiv dac\u{a} acesta nu poate fi modificat) \^{i}n funcție de modul de utilizare ales la deschiderea ferestre.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
  & \textbf{Add} & \textbf{Remove} & \textbf{Update} \\
\hline
\textbf{ID} & Inactiv & Inactiv & Inactiv \\
\hline
\textbf{Path/Index} & Activ & Inactiv & Activ \\
\hline
\textbf{Name} & Activ & Inactiv & Activ \\
\hline
\textbf{Type} & Activ & Inactiv & Activ \\
\hline
\textbf{Key} & Inactiv & Inactiv & Activ \\
\hline
\textbf{Run Test} & Activ & Activ & Activ \\
\hline
\end{tabular}
\caption{Elementele ferestrei și starea lor de funcționare pentru fiecare mod de utilizare}
\end{table}

Deși unele elemente sunt inactive \^{i}n anumite situații, acestea sunt vizibile pe pagin\u{a} și actualizate automat doar de c\u{a}tre aplicație, nefiind modificabile de c\u{a}tre utilizator. 

A doua parte a ferestrei, destinat\u{a} vizualiz\u{a}rii tuturor camerelor video existente și a schimb\u{a}rii chenarului implicit \^{i}n care aceasta se poate vizualiza \^{i}n direct, este poziționat\u{a} \^{i}n partea dreapt\u{a} și conține urm\u{a}toarele elemente:

\begin{itemize}
    \item Cameras List (QListWidget) - lista de widget-uri ce conține toate camerele existente \^{i}n aplicație.
    \item Slot1 (QPushButton) - buton pentru schimbarea chenarului implicit \^{i}n chenarul 1 pentru camera selectat\u{a} din lista de widget-uri.
    \item Slot2 (QPushButton) - buton pentru schimbarea chenarului implicit \^{i}n chenarul 2 pentru camera selectat\u{a} din lista de widget-uri.
\end{itemize}

Indiferent de modul de utilizare ales, toate elementele acestei p\u{a}rți sunt complet funcționale.

Lista de widget-uri \textbf{"Cameras List"} conține de fapt mai multe widget-uri ce mapeaz\u{a} c\u{a}tre un obiect de tip Camera (camer\u{a} video). Astfel c\u{a} selectarea unei camere video din list\u{a} va duce automat la completarea detaliilor despre aceasta \^{i}n elementele din st\^{a}nga paginii și reținerea acesteia \^{i}n cazul schimb\u{a}rii chenarului implicit.

\textbf{Ad\u{a}ugarea} (Add) unei camere video const\u{a} \^{i}ntr-un proces simplu \^{i}n care utilizatorul este nevoit s\u{a} introduc\u{a} path-ul sau index-ul camerei video, numele dorit pentru aceasta și tipul ei (ENTRANCE, EXIT, PARKING). Chiar dac\u{a} ID-ul este gol sau a fost completat automat \^{i}n urma select\u{a}rii unei camere video din list\u{a}, acesta nu va fi luat \^{i}n vedere iar generarea acestuia va fi efectuat\u{a} automat de c\u{a}tre baza de date la salvarea camerei video. Camera video ad\u{a}ugat\u{a} va fi pornit\u{a} doar dup\u{a} acționarea butonului "Refresh" din pagina principal\u{a} sau dup\u{a} repornirea aplicației.

Procesul de \textbf{ștergere} (Remove) a unei camere video este probabil cel mai simplu, utilizatorul fiind nevoit s\u{a} selecteze o camer\u{a} video din list\u{a}, s\u{a} se asigure prin verificarea detaliilor camerei video selectate c\u{a} aceasta este cea corect\u{a} și dup\u{a} aceea s\u{a} acționeze butonul "Remove". Totuși, aceasta va continua s\u{a} funcționeze p\^{a}n\u{a} c\^{a}nd se va acționa butonul "Refresh" din pagina principal\u{a} sau se va reporni aplicația.

\textbf{Actualizarea} (Update) se realizeaz\u{a} prin selectarea din list\u{a} a camerei video dorite, urm\^{a}nd a se modifica detaliile dorite \^{i}n partea st\^{a}ng\u{a} a paginii. Actualizarea este absolut necesar\u{a} dac\u{a} se dorește ad\u{a}ugarea unei taste \^{i}n vederea declanș\u{a}rii unei acțiuni la ap\u{a}sarea acesteia, acest lucru nefiind posibil direct la ad\u{a}ugare. Tasta ad\u{a}ugat\u{a} poate fi orice liter\u{a} de la A la Z și trebuie s\u{a} fie neap\u{a}rat unic\u{a}. Pentru ca modific\u{a}rile s\u{a} intre \^{i}n efect, este necesar\u{a} acționarea butonului "Refresh" din pagina principal\u{a} sau repornirea aplicației.

\textbf{Schimbarea chenarului implicit} se efectueaz\u{a} prin simpla selectare a unei camere video din list\u{a} și a chenarului dorit (Slot1 sau Slot2). Chenarele vor fi actualizate cu noile camere video dup\u{a} repornirea aplicației sau a acțion\u{a}rii butonului "Refresh" din pagina principal\u{a}. Spre deosebire de camerele video \^{i}n sine, ce sunt salvate \^{i}ntr-o baz\u{a} de date, camerele video implicite din chenare sunt salvate \^{i}ntr-un fișier JSON numit "cameras.json", unde pentru fiecare din cele dou\u{a} chenare se va specifica ID-ul camerei video. \textbf{Modificarea camerei video dintr-un chenar prin intermediul meniului "Settings" este temporar\u{a}!}

Este important ca \^{i}nainte de acționarea butonului "Add" sau "Update" s\u{a} se verifice mai \^{i}nt\^{a}i funcționalitatea camerei video introduse prin acționarea butonului "Run Test", care va \^{i}ncerca s\u{a} deschid\u{a} camera video și s\u{a} preia un frame din aceasta. Existența unei camere video nefuncționale va rezulta \^{i}n activarea modului de reparare (repair mode) p\^{a}n\u{a} c\^{a}nd toate camerele existente vor fi funcționale. Aplicația va intra \^{i}n repair mode doar la re\^{i}nc\u{a}rcarea camerelor video, mai precis la deschiderea aplicației sau la acționarea butonului "refresh" de pe pagina principal\u{a}, iar \^{i}n cazul apariției unui defect la o camer\u{a} video \^{i}n timpul rul\u{a}rii, atunci nu se vor mai putea declanșa acțiuni de la aceasta, nefiind posibil\u{a} preluarea unui frame, \^{i}ns\u{a} aplicația va rula \^{i}n continuare f\u{a}r\u{a} probleme.

\subsubsection{Pagina "Parking Spaces Management"}

Pagina "Parking Spaces Management" ofer\u{a} posibilitatea utilizatorului de a ad\u{a}uga, șterge sau modifica locurile de parcare ce aparțin de o camer\u{a} video de tip PARKING. Aceasta este alc\u{a}tuit\u{a} din patru butoane, dou\u{a} liste de widget-uri și un chenar folosit pentru afișarea unei imagini. Deschiderea aceste pagini se realizeaz\u{a} prin acționarea butonului "Manage Parking Spaces" din cadrul meniului "Manage Cameras".

\begin{figure}[H]
  \centering
  \includegraphics[width=0.90\linewidth]{ImaginiAplicatii/ManageParking.jpg}
  \caption{Pagina "Parking Spaces Management".}
  \label{fig:aplicatie_pagina_parking_spaces_management}
\end{figure}

\^{I}n figura \ref{fig:aplicatie_pagina_parking_spaces_management} se observ\u{a} existența a dou\u{a} liste de widget-uri poziționate pe partea dreapt\u{a}, numite "Cameras" și "Spaces", și a unei imagini aflate \^{i}n partea st\^{a}ng\u{a} a paginii. Aceste trei elemente sunt str\^{a}ns legate \^{i}ntre ele, imaginea din chenar schimb\^{a}ndu-se \^{i}n funcție de camera video și locul de parcare ales.

Lista de widget-uri numit\u{a} \textbf{"Cameras"} conține toate camerele video de tip PARKING existente \^{i}n aplicație sub form\u{a} de widget-uri care mapeaz\u{a} la un obiect de tip Camera (camer\u{a} video). Astfel, selectarea uneia dintre camere va rezulta \^{i}n preluarea frame-ului curent de la camera video și afișarea acestuia \^{i}n chenar, dar și actualizarea listei de widget-uri "Spaces" cu locurile de parcare ale camerei respective.

Dup\u{a} selectarea unei camere din lista "Cameras", lista de widget-uri \textbf{"Spaces"} va conține toate locurile de parcare existente pentru camera respectiv\u{a} sub form\u{a} de widget-uri care mapeaz\u{a} la un obiect de tip ParkingSpace (loc de parcare). Selectarea unui loc de parcare va duce la desenarea pe frame-ul preluat de la camera video a unei cutii delimitatoare (bounding box) \^{i}n jurul acestuia. De asemenea, acesta va fi reținut \^{i}n cazul \^{i}n care se dorește ștergerea sau modificarea acestuia.

\textbf{Desenarea cutiei delimitatoare} se realizeaz\u{a} prin setarea a dou\u{a} puncte pe imaginea din chenar printr-un simplu click de la mouse. Primul punct poate reprezenta oricare dintre colțurile locului de parcare iar al doilea punct trebuie s\u{a} reprezinte colțul de pe diagonala celui ales anterior. Imediat dup\u{a} selectarea celui de-al doilea punct se va desena cutia delimitatoare (bounding box) pe imagine.

Pentru \textbf{ad\u{a}ugarea} unui loc de parcare nou este necesar\u{a} selectarea camerei video dorite și desenarea unei cutii delimitatoare pentru locul de parcare. Dac\u{a} zona delimitatoare a locului de parcare este corect\u{a} se va acționa butonul \textbf{"Confirm (Add)"}, iar \^{i}n caz contrar, butonul \textbf{"Reset Box"} care va șterge desenul de pe imagine și va reseta punctele alese. Dup\u{a} ad\u{a}ugarea locului de parcare, detectarea numerelor de \^{i}nmatriculare de pe acesta va \^{i}ncepe de \^{i}ndat\u{a}, f\u{a}r\u{a} a mai fi nevoie de acționarea butonului "Refresh" de pe pagina principal\u{a}.

\textbf{Ștergerea} unui loc de parcare se realizeaz\u{a} prin selectarea camerei video din lista "Cameras" \^{i}n care se afl\u{a} locul de parcare dorit, urmat de selectarea acestuia din lista "Spaces" și acționarea butonului \textbf{"Remove"}. Detectarea numerelor de \^{i}nmatriculare de pe acesta va lua sf\^{a}rșit imediat, nefiind nevoie de acționarea butonului "Refresh" din pagina principal\u{a}.

\textbf{Actualizarea} (Update) sau modificarea unui loc de parcare se obține prin selectarea locului de parcare dorit din lista "Spaces", urmat de schimbarea cutiei delimitatoare dac\u{a} se dorește schimbarea delimit\u{a}rii zonei, lucru realizat prin acționarea butonului "Reset Box" urmat de desenarea zonei noi, urm\^{a}nd \^{i}n final acționarea butonului \textbf{"Update"} și introducerea unui nume nou pentru locul de parcare respectiv, dac\u{a} este cazul. Noile schimb\u{a}ri vor intra \^{i}n efect imediat iar șoferii vor putea vizualiza noul nume al locului de parcare pe pagina web și detecția numerelor de \^{i}nmatriculare se va efectua pe noua zon\u{a}.

\subsubsection{Meniul "Manage Entries"}

Meniul "Manage Entries" este situat \^{i}n bara de meniuri aflat\u{a} \^{i}n susul paginii pe pagina principal\u{a}. Acționarea acestuia va deschide o list\u{a} de opțiuni ce țin de administrarea \^{i}nregistr\u{a}rilor \^{i}n baza de date. Opțiunile disponibile \^{i}n acest meniu sunt \textbf{"Force exit for an entry"} și \textbf{"Force action by photo"}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiAplicatii/MeniuManageEntries.jpg}
  \caption{Meniul "Manage Entries".}
  \label{fig:aplicatie_meniul_manage_entries}
\end{figure}

Opțiunea \textbf{Force exit for an entry} este folosit\u{a} pentru a putea \^{i}nregistra manual incheierea unei sesiuni \^{i}n situația \^{i}n care unui șofer nu i-a putut fi detectat și recunoscut num\u{a}rul de \^{i}nmatriculare și acesta a pierdut SecretID-ul sau nu reușește s\u{a}-l foloseasc\u{a}. \^{I}n figura \ref{fig:aplicatie_force_exit} se observ\u{a} existența a dou\u{a} QComboBox-uri, unul pentru selectarea sesiunii dorite a fi incheiate unde este scris ID-ul sesiunii și num\u{a}rul de \^{i}nmatriculare atribuit, dac\u{a} este cazul, și cel\u{a}lalt pentru selectarea camerei video de ieșire, unde este scris numele camerei al\u{a}turi de ID-ul acesteia \^{i}ntre paranteze. Camera video de ieșire selectat\u{a} va corespunde cu camera video la care se situeaz\u{a} autovehiculul \^{i}n momentul utiliz\u{a}rii acestei opțiuni.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.20\linewidth]{ImaginiAplicatii/ForceExit.jpg}
  \caption{Meniul opțiunii "Force exit for an entry".}
  \label{fig:aplicatie_force_exit}
\end{figure}

Opțiunea \textbf{Force action by photo} este utilizat\u{a} pentru a putea forța declanșarea unei acțiuni pentru o anumit\u{a} camer\u{a} video folosind o imagine. Folosirea acestei opțiuni este recomandat\u{a} \^{i}n momentul test\u{a}rii. \^{I}n figura \ref{fig:aplicatie_force_action} se poate observa existența unui QLineEdit, utilizat pentru introducerea path-ului c\u{a}tre imaginea dorit\u{a}, și un QComboBox utilizat pentru selectarea camerei video dorite pentru care se va declanșa o acțiune.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.30\linewidth]{ImaginiAplicatii/ForcePhoto.jpg}
  \caption{Meniul opțiunii "Force action by photo".}
  \label{fig:aplicatie_force_action}
\end{figure}

\subsubsection{Meniul "Settings"}

Meniul "Settings" se afl\u{a} \^{i}n bara de meniuri aflat\u{a} \^{i}n susul paginii pe pagina principal\u{a}. Acționarea acestuia va deschide o list\u{a} de opțiuni destinate schimb\u{a}rii anumitor set\u{a}ri. Opțiunile disponibile \^{i}n acest meniu sunt \textbf{View Specific Camera} și \textbf{Change Detection Type}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\linewidth]{ImaginiAplicatii/MeniulSettings.jpg}
  \caption{Meniul "Settings".}
  \label{fig:aplicatie_meniul_settings}
\end{figure}

Opțiunea \textbf{View Specific Camera} este folosit\u{a} pentru a schimba temporar camera video ce este vizualizat\u{a} \^{i}n cadrul unuia dintre cele dou\u{a} chenare de pe pagina principal\u{a}. Dup\u{a} repornirea aplicației sau acționarea butonului "Refresh", chenarele vor avea \^{i}napoi camerele video implicite. Schimbarea permanent\u{a} a camerei video dintr-un chenar se realizeaz\u{a} prin accesarea meniului "Manage Cameras", opțiunea "Add", "Remove" sau "Update" și acționarea butonului "Slot1" sau "Slot2", \^{i}n funcție de chenarul dorit. \^{I}n cazul de faț\u{a}, se va selecta slotul dorit din primul QComboBox, urmat de camera video dorit\u{a} a fi vizualizat\u{a}, de pe al doilea QComboBox. Schimbarea va fi imediat\u{a} iar acționarea butonului "Refresh" pentru actualizarea camerelor video nu va fi necesar\u{a}!

\begin{figure}[H]
  \centering
  \includegraphics[width=0.20\linewidth]{ImaginiAplicatii/ViewSlot.jpg}
  \caption{Meniul opțiunii "View Specific Camera".}
  \label{fig:aplicatie_view_slot}
\end{figure}

Opțiunea \textbf{Change Detection Type} este utilizat\u{a} pentru schimbarea modului \^{i}n care se realizeaz\u{a} detecția pl\u{a}cuței de \^{i}nmatriculare pentru un anumit tip de camer\u{a}. Implicit, detecția se realizeaz\u{a} folosind modul \textbf{IMAGE\_PROCESSING} pentru tipurile \textbf{ENTRANCE} și \textbf{EXIT}, și \textbf{DNN} pentru tipul \textbf{PARKING}. Aceste schimb\u{a}ri vor fi salvate \^{i}ntr-un fișier JSON numit "detections.json" și vor intra \^{i}n efect de \^{i}ndat\u{a}, nefiind necesar\u{a} actualizarea camerelor video folosind butonul "Refresh". \^{I}n figura \ref{fig:aplicatie_change_detection} se poate observa existența a dou\u{a} QComboBox-uri, unul pentru selectarea tipului de camer\u{a} (ENTRANCE, EXIT sau PARKING) ce va folosi noul mod de detecție, și cel\u{a}lalt pentru selectarea noului mod de detecție (IMAGE\_PROCESSING sau DNN).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.30\linewidth]{ImaginiAplicatii/ChangeDetectionType.jpg}
  \caption{Meniul opțiunii "Change Detection Type".}
  \label{fig:aplicatie_change_detection}
\end{figure}

\subsection{Aplicația Java}

\subsubsection{Arhitectura}

Asem\u{a}n\u{a}tor aplicației C++, și \^{i}n implementarea aplicației web folosind Java s-a folosit arhitectura Model-View-Controller (MVC), \^{i}ns\u{a} cu unele diferențe. Dac\u{a} \^{i}n aplicația C++ se folosea \^{i}n principal arhitectura MVC iar \^{i}n cadrul componentei Model se folosea arhitectura pe trei nivele pentru manipularea \^{i}nregistr\u{a}rilor \^{i}n baza de date, \^{i}n aplicația web implementat\u{a} \^{i}n Java se folosesc toate cele trei componente, Model, View și Controller, \^{i}mpreun\u{a} cu \^{i}nc\u{a} dou\u{a} componente, Service și Repository. Acestea din urm\u{a} sunt responsabile cu manipularea \^{i}nregistr\u{a}rilor bazei de date, \^{i}n timp ce celelalte trei componente se ocup\u{a} de logica aplicației și prezentarea datelor c\u{a}tre utilizatori.

\begin{itemize}
    \item Model - este reprezentarea datelor aplicației și include clasele Java care definesc structura datelor și logica asociat\u{a} acestora.
    \item Controller - este reponsabil pentru gestionarea cererilor HTTP primite de la client și pentru a comunica cu celelalte componente ale aplicației. Acestea sunt punctele de intrare \^{i}n aplicație și sunt responsabile pentru direcționarea cererilor c\u{a}tre serviciile adecvate și pentru returnarea r\u{a}spunsurilor c\u{a}tre client.
    \item Fișierele HTML (View) - sunt fișierele care definesc interfața utilizatorului. Ele pot folosi șabloane sau framework-uri de frontend, cum ar fi Thymeleaf sau AngularJS, pentru a obține datele din backend și pentru a le putea afișa \^{i}n mod corespunz\u{a}tor.
    \item Repository - este componenta responsabil\u{a} de interacțiunea cu baza de date și include operații CRUD (Create, Read, Update, Delete) pentru a accesa și manipula datele.
    \item Service - este componenta care conține logica de afaceri (engl. BusinessLogic) a aplicației și este responsabil\u{a} pentru procesarea datelor și implementarea logicii aplicației. De obicei, componenta Controller va comunica cu componenta Service pentru executarea operațiilor necesare pe date.
\end{itemize}

\subsubsection{Realizarea interfeței grafice}

\^{I}n cadrul aplicației Java a fost integrat motorul de șabloane numit Thymeleaf \^{i}n vederea gestion\u{a}rii fișierelor HTML și realiz\u{a}rii interfeței utilizatorului. Thymeleaf a fost alegerea preferat\u{a} datorit\u{a} flexibilit\u{a}ții și puterii sale \^{i}n crearea paginilor web dinamice. Prin intermediul Thymeleaf, au fost create și gestionate pagini web interactive, care comunic\u{a} eficient cu logica de backend a aplicației. Thymeleaf ofer\u{a} o modalitate elegant\u{a} de a combina codul HTML static cu expresii dinamice și logica de afișare a datelor din backend.

Pentru \^{i}nceput, se creeaz\u{a} fișierele HTML care definesc structura și aspectul paginii web. Thymeleaf permite utilizarea unor construcții speicale \^{i}n cadrul acestor fișiere pentru a face referire la obiectele și datele din backend. Aceste construții speciale sunt adesea integrate direct \^{i}n codul HTML folosind o sintax\u{a} specific\u{a} sau diferite atribute, facilit\^{a}nd astfel manipularea și afișarea dinamic\u{a} a datelor.

Pe durata dezvolt\u{a}rii interfeței se folosesc funcționalit\u{a}țile oferite de motorul de șabloane pentru a se utiliza, de exemplu, bucle care itereaz\u{a} printr-o list\u{a} de obiecte și afișarea fiec\u{a}rui element \^{i}ntr-un mod structurat pe pagin\u{a}, sau condiții pentru afișarea sau ascunderea anumitor elemente pe baza unor condiții din backend.
%țș

De asemenea, o alt\u{a} caracteristic\u{a} puternic\u{a} este capacitatea sa \^{i}n procesarea formularelor HTML și gestionarea trimiterii datelor \^{i}napoi c\u{a}tre server. De exemplu, se pot realiza diferite valid\u{a}ri sau prelucr\u{a}ri a datelor introduse de c\u{a}tre utilizatori.

Pentru ad\u{a}ugarea unui stil și a unui aspect pl\u{a}cut paginilor web s-a folosit și CSS (Cascading Style Sheets). Acesta permite controlarea modului \^{i}n care elementele HTML sunt afișate \^{i}n browser, de la fonturi și culori, la layout-uri și dimensiuni.

Un exemplu de utilizare \^{i}n cadrul aplicației este definirea de stiluri CSS pentru elementele de tip text, precum dimensiunea fontului, culoarea și tipul de font utilizat. Au fost create clase CSS pentru a standardiza aspectul textului \^{i}n \^{i}ntreaga aplicație, asigur\^{a}nd faptul c\u{a} mesajele și informațiile sunt prezentate \^{i}ntr-un mod clar și ușor de citit pentru utilizatori. Un alt exemplu \^{i}n folosirea CSS-ului este ad\u{a}ugarea de culori și tabele pentru \^{i}mbun\u{a}t\u{a}țirea aspectului general al paginilor web din cadrul aplicației, cre\^{a}ndu-se astfel un mediu vizual atr\u{a}g\u{a}tor pentru utilizatori.

\^{I}n plus, CSS-ul a fost esențial pentru definirea comportamentului elementelor de interfaț\u{a}, cum ar fi butoanele, meniurile și alte elemente interactive. Au fost utilizate stiluri CSS pentru evidențierea elementelor de acest tip, pentru a le putea oferi efecte de hover sau pentru a le adapta aspectul \^{i}n funcție de acțiunile utilizatorului.

Av\^{a}nd modul \^{i}n care tehnologiile prezentate compun interfața grafic\u{a} a aplicației, se poate trece la evidențierea funcționalit\u{a}ții și prezent\u{a}rii acesteia.

\subsubsection{Autentificarea (/login, /register, /passwordReset)}

Autentificarea este un proces esențial pentru securizarea aplicațiilor web bazate pe framework-ul Spring ce se realizeaz\u{a} cu ajutorul componentei Spring Security. Aceasta ofer\u{a} un set puternic de funcționalit\u{a}ți pentru gestionarea autentific\u{a}rii utilizatorilor și autorizarea accesului la resursele aplicației.

Pentru implementarea autentific\u{a}rii \^{i}n Spring Security, primul pas const\u{a} \^{i}n configurarea unui sistem de autentificare. Acest lucru const\u{a} \^{i}n definirea modului de autentificare, cum ar fi autentificarea pe baza unui utilizator și a unei parole stocate \^{i}ntr-o baz\u{a} de date sau autentificarea pe baza unor mecanisme externe, precum LDAP sau OAuth. \^{I}n cazul aplicației web prezentate, s-a folosit modul de autentificare bazat pe un utilizator și o parol\u{a} stocat\u{a} \^{i}ntr-o baz\u{a} de date.

Odat\u{a} ce sistemul de autentificare este configurat, Spring Security gestioneaz\u{a} \^{i}ntregul proces de autentificare, inclusiv verificarea datelor (credențialelor) utilizatorului și gestionarea sesiunilor. De asemenea, Spring Security ofer\u{a} funcționalit\u{a}ți avansate de securitate, precum protecția \^{i}mpotriva atacurilor de tip "brute force" și gestionarea centralizat\u{a} a politicilor de securitate.

\^{I}n plus, Spring Security faciliteaz\u{a} implementarea autoriz\u{a}rii, permiț\^{a}nd definirea unor reguli detaliate pentru controlul accesului la resursele aplicației \^{i}n funcție de rolurile și permisiunile utilizatorilor.
%țș

La accesarea aplicației web, utilizatorul este redirecționat automat c\u{a}tre pagina de autentificare \textbf{(/login)}. Aici, utilizatorul este nevoit s\u{a} \^{i}și introduc\u{a} datele de conectare pentru a putea accesa funcționalit\u{a}țile aplicației. 

Autentificarea se realizeaz\u{a} folosind un num\u{a}r de \^{i}nmatriculare și o parol\u{a}. \^{I}n \ref{fig:aplicatie_login_page} se poate observa meniul de login folosit pentru autentificare. Acesta include dou\u{a} textbox-uri, unul pentru introducerea num\u{a}rului de \^{i}nmatriculare (License Plate) și unul pentru introducerea parolei, dou\u{a} texte ce redirecționeaz\u{a} utilizatorul c\u{a}tre o pagin\u{a} destinat\u{a} ieșirii forțate din parcare folosind SecretID-ul \textbf{("Stuck in the parking place?")}, nefiind nevoie de autentificare, și c\u{a}tre o alt\u{a} pagin\u{a} destinat\u{a} schimb\u{a}rii parolei \textbf{("Forgot your password?")}, și de asemenea un buton pentru finalizarea autentific\u{a}rii. Pentru o vizualizare mai adecvat\u{a} a acestui meniu, fundalul acestuia a fost șters astfel \^{i}nc\^{a}t s\u{a} se poat\u{a} observa \^{i}n figura \ref{fig:aplicatie_login_page} toate detaliile necesare.

Dup\u{a} acționarea butonului \textbf{"Sign in"}, dac\u{a} datele introduse sunt corecte, utilizatorul este logat și redirecționat c\u{a}tre pagina principal\u{a} \textbf{(/home)}, iar \^{i}n caz contrar, acesta va fi anunțat de faptul c\u{a} num\u{a}rul de \^{i}nmatriculare sau parola nu sunt corecte.
%țș

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\linewidth]{ImaginiAplicatii/webLogin.jpg}
  \caption{Meniul de login din pagina de autentificare.}
  \label{fig:aplicatie_login_page}
\end{figure}

\^{I}nainte ca un utilizator s\u{a} se logheze, acesta trebuie s\u{a} \^{i}și creeze mai \^{i}nt\^{a}i un cont de utilizator folosind SecretID-ul primit la intrarea \^{i}n parcare. Acest cod special (SecretID) este unic pentru fiecare intrare \^{i}nregistrat\u{a} \^{i}n parcare și poate fi folosit pentru crearea unui cont doar dac\u{a} aparține unei sesiuni de parcare \^{i}n curs, nu exist\u{a} deja un cont și s-a putut detecta cu succes num\u{a}rul de \^{i}nmatriculare. Acest SecretID va conține o secvenț\u{a} de numere, urmat\u{a} de num\u{a}rul de \^{i}nmatriculare detectat pentru sesiunea respectiv\u{a}, de exemplu, "1705533880505549\textbf{BV01ABC}". De asemenea, utilizatorului va trebui s\u{a} introduc\u{a} o parol\u{a} ce conține minim 8 caractere, \^{i}ncluz\^{a}nd cel puțin o liter\u{a} mare, un num\u{a}r și un caracter special. Pentru a \^{i}ncepe procesul de \^{i}nregistrare a unui cont, utilizatorul va ap\u{a}sa pe textul de sub meniul de login \textbf{"Don't have an account? Sign up!"} și va fi redirecționat c\u{a}tre pagina de creare a unui cont de utilizator \textbf{(/register)}.
%țș

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\linewidth]{ImaginiAplicatii/webRegister.jpg}
  \caption{Meniul de register din pagina de creare a unui cont de utilizator.}
  \label{fig:aplicatie_register_page}
\end{figure}

Așa cum se poate observa \^{i}n meniul din figura \ref{fig:aplicatie_register_page}, utilizatorul este nevoit s\u{a} introduc\u{a} un SecretID și parola dorit\u{a}, urmat\u{a} de repetarea acesteia. Dup\u{a} acționarea butonului \textbf{"Sign Up"}, dac\u{a} datele introduse sunt corecte, acesta va fi redirecționat c\u{a}tre pagina de autentificare și se poate autentifica folosind num\u{a}rul s\u{a}u de \^{i}nmatriculare și parola introdus\u{a}.

\^{I}n cazul uit\u{a}rii parolei, utilizatorii pot accesa pagina destinat\u{a} reset\u{a}rii parolei \textbf{"/passwordReset"} din pagina de autentificare printr-un click pe text-ul \textbf{("Forgot your password?")}. Pentru a realiza acest lucru cu succes, utilizatorul va avea nevoie de SecretID-ul sesiunii aflate \^{i}n desf\u{a}șurare, \^{i}nsemn\^{a}nd c\u{a} șoferul nu a p\u{a}r\u{a}sit \^{i}nc\u{a} parcarea, cu condiția ca SecretID-ul s\u{a} conțin\u{a} num\u{a}rul de \^{i}nmatriculare.

Toate parolele conturilor vor fi criptate și nu vor putea fi vizualizate \^{i}n baza de date.

\subsubsection{Pagina principal\u{a} (/home)}

Odat\u{a} autentificat, utilizatorul este redirecționat c\u{a}tre pagina principal\u{a} \textbf{(/home)}. Aceasta este compus\u{a} dintr-un meniu aflat \^{i}n partea de sus a paginii, ce conține trei butoane ce vor redirecționa utilizatorul c\u{a}tre o alt\u{a} pagin\u{a}, de exemplu "Home", c\u{a}tre pagina principal\u{a}, "Chat", c\u{a}tre pagina de \^{i}ntreb\u{a}ri și r\u{a}spunsuri, și "Log out" pentru delogarea din contul curent, și un tabel ce va include toate sesiunile \^{i}n care num\u{a}rul de \^{i}nmatriculare cu care s-a efectuat autentificarea a fost detectat. 
%țș

\begin{figure}[H]
  \centering
  \includegraphics[width=0.999\linewidth]{ImaginiAplicatii/webMain.jpg}
  \caption{Pagina principal\u{a} (/home).}
  \label{fig:aplicatie_pagina_principala}
\end{figure}

Așa cum se poate observa \^{i}n figura \ref{fig:aplicatie_pagina_principala}, pagina const\u{a} \^{i}n mare parte \^{i}ntr-un tabel alc\u{a}tuit din opt coloane, unde fiecare \^{i}nregistrare a acestuia reprezint\u{a} o sesiune de parcare. Mai jos vor fi prezentate pe r\^{a}nd toate coloanele tabelului:

\begin{itemize}
    \item ID - Num\u{a}r unic de identificare a unei sesiuni.
    \item Entrance Date - Data și ora la care a fost \^{i}nceput\u{a} sesiunea, mai precis c\^{a}nd a intrat \^{i}n parcare).
    \item Exit Date - Data și ora la care a fost \^{i}ncheiat\u{a} sesiunea, mai precis c\^{a}nd a ieșit din parcare).
    \item Time Spent (min) - Timpul petrecut \^{i}n minute \^{i}n interiorul parc\u{a}rii.
    \item Parking History - Buton pentru vizualizarea locurilor de parcare unde num\u{a}rul de \^{i}nmatriculare al utilizatorului a fost detectat. Mai exact, locurile de parcare pe care șoferul a parcat.
    \item Status - Starea sesiunii.
    \item SecretID - Buton pentru vizualizarea SecretID-ului asociat sesiunii.
    \item Report - Buton pentru raportarea unei probleme pe durata sesiunii.
\end{itemize}

La acționarea butonului \textbf{"View"} de pe coloana \textbf{"Parking History"}, utilizatorul este redirecționat c\u{a}tre o pagin\u{a} \textbf{(/home/spaces/\{ID sesiune})\} unde acesta va putea vizualiza, sub form\u{a} de tabel, toate locurile de parcare pe care acesta a parcat \^{i}n cadrul sesiunii respective. \^{I}n cadrul tabelului va ap\u{a}rea numele acestuia, care se recomand\u{a} a fi c\^{a}t mai sugestiv astfel \^{i}nc\^{a}t, \^{i}n cazul uit\u{a}rii acestuia, șoferul s\u{a} iși poat\u{a} localiza mașina cu ușurinț\u{a}. Tabelul mai conține data și ora la care num\u{a}rul de \^{i}nmatriculare a fost localizat \^{i}n zona delimitatoare a locului de parcare și la care l-a p\u{a}r\u{a}sit. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.999\linewidth]{ImaginiAplicatii/viewSpace.jpg}
  \caption{Pagina pentru vizualizarea locurilor de parcare \^{i}n care num\u{a}rul de \^{i}nmatriculare pentru sesiunea respectiv\u{a} a fost detectat. (/home/spaces/\{ID sesiune\}).}
  \label{fig:aplicatie_pagina_spaces}
\end{figure}

Așadar, utilizatorul este redirecționat c\u{a}tre o pagin\u{a} \^{i}n funcție de ID-ul sesiunii respective. \^{I}n cazul sesiunii cu ID 2, utilizatorul este redirecționat c\u{a}tre "/home/spaces/2". Același lucru se va \^{i}ntampla și la acționarea butonului \textbf{"View"} de pe coloana \textbf{"SecretID"}, utilizatorul fiind redirecționat c\u{a}tre pagina \textbf{"/home/viewSecretID/\{ID sesiune\}} unde \^{i}și va putea vizualiza SecretID-ul pentru sesiunea dorit\u{a}.

Acționarea butonului \textbf{"Create Report"} va redirecționa utilizatorul c\u{a}tre o pagin\u{a} destinat\u{a} inițializ\u{a}rii unui raport, pagin\u{a} ce va fi prezentat\u{a} \^{i}n capitolul 6.2.6. Link-ul acestei pagini va fi tot de tipul celor prezentate anterior, acesta fiind \textbf{"/report/create/\{ID sesiune\}"}.

Butonul \textbf{"Chat"} din partea de sus a paginii va redirecționa utilizatorul c\u{a}tre pagina de \^{i}ntreb\u{a}ri și r\u{a}spunsuri \textbf{(/chat)}, aceasta fiind disponibil\u{a} tuturor utilizatorilor. Butonul \textbf{"Home"} va redirecționa utilizatorul c\u{a}tre pagina principal\u{a} \textbf{(/home)}. Cele dou\u{a} butoane, al\u{a}turi de \textbf{"Log out"}, vor fi disponibile \^{i}n orice moment \^{i}n cadrul meniului din partea de sus a unei pagini.
%țș

Este evident faptul c\u{a} un utilizator va putea intra pur și simplu pe o pagin\u{a}, ca de exemplu "/home/spaces/1000", a c\u{a}rui ID de sesiune nu \^{i}i aparține. \^{I}n acest caz, utilizatorul va fi putea accesa pagina \^{i}ns\u{a}, \^{i}n loc s\u{a} fie \^{i}nt\^{a}mpinat de tabelul cu locurile de parcare, acesta va vedea un mesaj care \^{i}l va anunța c\u{a} nu \^{i}i este permis s\u{a} vizualizeze aceast\u{a} pagin\u{a}, exact ca \^{i}n figura \ref{fig:aplicatie_missing_permission}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.50\linewidth]{ImaginiAplicatii/webMissingPermission.jpg}
  \caption{Accesarea unei pagini la care utilizatorul nu are acces.}
  \label{fig:aplicatie_missing_permission}
\end{figure}

\subsubsection{Pagina și contul de administrator (/admin)}

Din oficiu, va exista un cont special de administrator ce va avea num\u{a}rul de \^{i}nmatriculare (username-ul) \textbf{"ADMIN"} și parola \textbf{"pass"}. Acesta va putea accesa pagini suplimentare, \^{i}ns\u{a} nu va putea vizualiza date legate de sesiunile utilizatorilor.

Spre deosebire de contul de utilizator ce este redirecționat c\u{a}tre pagina principal\u{a} dup\u{a} autentificare, contul de administrator este redirecționat c\u{a}tre o pagin\u{a} special\u{a} numit\u{a} pagina de administrator \textbf{(/admin)}, ce este accesibil\u{a} doar acestui cont.

Aceast\u{a} pagin\u{a} este compus\u{a} dintr-un meniu de butoane aflat \^{i}n partea de sus a paginii și un tabel ce se afl\u{a} sub acesta. 

Meniul de butoane seam\u{a}n\u{a} cu cel al unui cont de utilizator, av\^{a}nd cele trei butoane clasice, "Home", "Chat", și "Log out", plus \^{i}nc\u{a} dou\u{a} butoane destinate contului de administrator, \textbf{"Admin"} și \textbf{"Reports"}. Butonul "Admin" va redirecționa administratorul c\u{a}tre pagina de administrator \textbf{(/admin)}, iar "Reports" c\u{a}tre pagina de raporturi \textbf{(/report/list)}.

Tabelul din aceast\u{a} pagin\u{a} este compus din patru coloane \^{i}n care fiecare \^{i}nregistrare a acestuia va reprezenta un cont de utilizator. Administratorul va avea posibilitatea vizualiz\u{a}rii tuturor conturilor de utilizator, al\u{a}turi de ID-ul și num\u{a}rul de \^{i}nmatriculare al acestora, și a schimb\u{a}rii parolei sau chiar a ștergerii contului, dac\u{a} este cazul. \^{I}n figura \ref{fig:aplicatie_admin_main} se poate observa pagina de administrator, al\u{a}turi de tabelul și meniul de butoane specific al acesteia.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.999\linewidth]{ImaginiAplicatii/webAdminMain.jpg}
  \caption{Pagina de administrator (/admin).}
  \label{fig:aplicatie_admin_main}
\end{figure}

\subsubsection{Pagina de raporturi (/report/list)}

Este inevitabil ca șoferii s\u{a} nu \^{i}nt\^{a}mpine anumite dificult\u{a}ți sau probleme pe durata șederii \^{i}n parcare, astfel c\u{a}, posibilitatea raport\u{a}rii acestora este necesar\u{a} \^{i}ntr-un mod sau altul.

Utilizatorii vor putea iniția un raport prin acționarea butonului \textbf{"Create Report"} de pe linia sesiunii \^{i}n care a avut loc problema, aceștia fiind redirecționați c\u{a}tre pagina dedicat\u{a} cre\u{a}rii unui raport \textbf{(/report/create/{ID sesiune}}. Aceștia vor putea crea oric\^{a}te rapoarte doresc pentru oricare dintre sesiuni, fie c\u{a} ele sunt \^{i}nc\u{a} active sau nu. \^{I}n cadrul unu raport, utilizatorul va introduce num\u{a}rul de \^{i}nmatriculare al suspectului, intervalul orar aproximativ la care s-a \^{i}ntamplat, detaliile problemei și metoda prin care s\u{a} fie contactat. Spre exemplu, \^{i}n cazul \^{i}n care un șofer cu num\u{a}rul de \^{i}nmatriculare A observ\u{a} o tamponare, \^{i}n care un șofer cu num\u{a}rul B atinge o mașin\u{a} parcat\u{a} cu num\u{a}rul C, acesta va crea un raport specific\^{a}nd num\u{a}rul de \^{i}nmatriculare al autovehiculului suspect, adic\u{a} B, și al victimei \^{i}n detalii, adic\u{a} C.

Raporturile create de c\u{a}tre utilizatori vor putea fi vizualizate doar de c\u{a}tre un cont de administrator pe pagina de raporturi \textbf{"/report/list"}. Acesta va putea accesa aceast\u{a} pagin\u{a} fie prin acționarea butonului \textbf{"Reports"} de pe pagina de administrator, fie prin accesarea link-ului \textbf{/report/list} din aplicația web. Lista de raporturi din cadrul acestei pagini este tot sub form\u{a} de tabel, fiind compus\u{a} din 6 coloane:

\begin{itemize}
    \item ID - Num\u{a}r unic de identificare a raportului.
    \item Session ID - Num\u{a}rul unic de identificare a sesiunii pentru care a fost creat raportul.
    \item Reporter - Num\u{a}rul de \^{i}nmatriculare al persoanei ce a creat raportul sau a victimei.
    \item Suspect - Num\u{a}rul de \^{i}nmatriculare al persoanei raportate sau a suspectului.
    \item Status - Starea raportului, OPEN, dac\u{a} nu a fost soluționat, și CLOSED, dac\u{a} a fost soluționat.
    \item View - buton pentru vizualizarea detaliilor legate de raport și pentru setarea st\u{a}rii acestuia.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.999\linewidth]{ImaginiAplicatii/webAdminReportList.jpg}
  \caption{Pagina de raporturi (/report/list).}
  \label{fig:aplicatie_admin_report}
\end{figure}

Odat\u{a} acționat, butonul \textbf{"View"} va rezulta \^{i}n redirecționarea administratorului c\u{a}tre pagina raportului \textbf{("/report/view/{ID Raport})}. Acolo, administratorul va putea vizualiza orice detaliu legat de raport ce a fost oferit de c\u{a}tre persoana ce a \^{i}ntocmit raportul, detaliu precum ora la care s-a \^{i}ntamplat, persoanele implicate și altele. Dup\u{a} eventuala soluționare a acestuia, administratorul va putea folosi butonul \textbf{"Close Report"} de pe aceast\u{a} pagin\u{a} pentru a marca starea raportului ca fiind \textbf{CLOSED}. Totuși, dac\u{a} dintr-un motiv sau altul raportul are nevoie de continuarea investigației, administratorul va acționa butonul \textbf{"Open Report"} pentru a marca starea raportului ca fiind \textbf{OPEN}.

\subsubsection{Pagina de \^{i}ntreb\u{a}ri și r\u{a}spunsuri (/chat)}

Pagina de \^{i}ntreb\u{a}ri și r\u{a}spunsuri poate fi accesat\u{a} folosind at\^{a}t un cont de utilizator, c\^{a}t și un cont de administrator, prin intermediul butonului \textbf{"Chat"} aflat \^{i}n partea de sus a paginii. Aceast\u{a} pagin\u{a} este destinat\u{a} adres\u{a}rii de \^{i}ntreb\u{a}ri de c\u{a}tre utilizatori unde vor putea fi r\u{a}spunse de alți utilizatori sau chiar de administrator. O alt\u{a} folosinț\u{a} a acesteia ar mai putea fi și comunicarea de anunțuri importante ce țin de parcare, precum \^{i}nchiderea acesteia de s\u{a}rbatori, evitarea unei ieșiri \^{i}nchise, renovarea acesteia, existența unor lucr\u{a}ri pe anumite zone și altele.

\^{I}n vederea trimiterii unui mesaj \^{i}n "chat", utilizatorii vor ap\u{a}sa pe textul "Have any questions? \textbf{Post them here!}" aflat sub meniul din partea de sus a paginii de \^{i}ntreb\u{a}ri și r\u{a}spunsuri dup\u{a} care vor introduce mesajul dorit.

Pentru ca mesajele trimise de c\u{a}tre un cont de administrator s\u{a} ias\u{a} \^{i}n evidenț\u{a}, acestea vor avea text de culoare alb\u{a} pe un fundal de culoare roșie, pe c\^{a}nd cele trimise de c\u{a}tre un cont de utilizator vor avea text de culoare neagr\u{a} pe fundal de culoare gri.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.999999\linewidth, height=10cm]{ImaginiAplicatii/webChat.jpg}
  \caption{Pagina de \^{i}ntreb\u{a}ri și r\u{a}spunsuri (/chat).}
  \label{fig:aplicatie_chat}
\end{figure}

Mesajele trimise \^{i}n acest chat nu vor fi salvate \^{i}n baza de date, ci \^{i}ntr-un fișier de tip JSON numit \textbf{"globalMessages.json"}, unde fiecare mesaj va conține un \textbf{sender}, reprezent\^{a}nd persoana ce a trimis mesajul, un \textbf{timestamp}, reprezent\^{a}nd data și ora la care a fost trimis și un \textbf{text}, fiind text-ul mesajului \^{i}n sine.
%țș

\subsubsection{P\u{a}r\u{a}sirea parc\u{a}rii folosind SecretID (/stuck)}

Se poate \^{i}nt\^{a}mpla ca la intrare, num\u{a}rul de \^{i}nmatriculare s\u{a} nu poat\u{a} fi detectat sau s\u{a} fi fost incorect detectat la intrare dar corect detectat la ieșire, caz \^{i}n care ieșirea nu va putea fi efectuat\u{a} cu succes.

Ca alternativ\u{a} la apelarea la o persoan\u{a} autorizat\u{a} pentru ajutor, s-a decis crearea unei pagini speciale, ce poate fi accesat\u{a} f\u{a}r\u{a} a avea cont de utilizator, prin care un șofer s\u{a} poat\u{a} forța declanșarea unei acțiuni pentru o camer\u{a} video de tip EXIT. Mai exact, se va marca sf\^{a}rșitul sesiunii iar bariera parc\u{a}rii s-ar deschide, dac\u{a} este cazul, la ieșirea dat\u{a}.

Astfel, p\u{a}r\u{a}sirea parc\u{a}rii folosind SecretID se realizeaz\u{a} prin completarea datelor necesare de pe pagina specific\u{a} ce poate fi accesat\u{a} printr-un clic pe textul \textbf{"Stuck in the parking lot?"} aflat pe pagina de autentificare. Datele necesare pentru efectuarea cu succes a p\u{a}r\u{a}sirii forțate a parc\u{a}rii sunt SecretID-ul sesiunii și "Leaving Gate-ul", adic\u{a} ID-ul porții de ieșire la care se afl\u{a} șoferul \^{i}n momentul complet\u{a}rii acestora.
%țș

\newpage

\section{Concluzii și dezvoltări ulterioare}

\subsection{Concluzii generale}

\^{I}n concluzie, prin acest\u{a} lucrare, intitulat\u{a} "Sistem integrat de monitorizare și gestionare a unei parc\u{a}ri auto cu platform\u{a} web interactiv\u{a}", s-au realizat dou\u{a} aplicații, una care s\u{a} se ocupe de detectarea și recunoașterea automat\u{a} a numerelor de \^{i}nmatriculare ale autovehiculelor și de gestionarea lor, și cealalt\u{a} care s\u{a} cuprind\u{a} c\^{a}t mai profund nevoile șoferilor de autovehicule atunci c\^{a}nd staționeaz\u{a} \^{i}ntr-o parcare, precum vizualizarea timpului petrecut \^{i}n parcare, locurile pe care aceștia au parcat, adresarea cu ușurinț\u{a} a eventualelor \^{i}ntreb\u{a}ri sau chiar sesizarea unor probleme direct de pe aplicația web. Astfel, principalele caracteristici ale celor dou\u{a} aplicații dezvoltate sunt: ușurința \^{i}n utilizare, robustețea, extensibilitatea și folosirea de tehnologii moderne. 

Pentru ca produsul final s\u{a} fie unul pe m\u{a}sura aștept\u{a}rilor, au fost urmați anumiți pași ce au oferit rezultate bune. Deși au fost \^{i}ncercate mai multe variante pentru implementarea anumitor algoritmi \^{i}n procesul de detectare și recunoaștere a numerelor de \^{i}nmatriculare, proiectul conține doar acele metode care au oferit cele mai bune rezultate. 

\^{I}n acest sens, primul pas urm\u{a}rit a fost cel de detectare și recunoaștere a numerelor de \^{i}nmatriculare ale unui autovehicul. \^{I}n primul r\^{a}nd, pentru detectarea pl\u{a}cuței unde se afl\u{a} num\u{a}rul de \^{i}nmatriculare, s-a f\u{a}cut o preprocesare, care a servit scopul de a prelucra imaginea astfel \^{i}nc\^{a}t s\u{a} fie mai ușor de identificat și segmentat pl\u{a}cuța de \^{i}nmatriculare. Apoi, folosindu-ne de contururi, s-a realizat o filtrare a acestora, urm\^{a}nd a fi ales conturul ce delimiteaz\u{a} pl\u{a}cuța de \^{i}nmatriculare. Detectarea pl\u{a}cuței folosind metoda prezentat\u{a} a fost un succes, reușind identificarea pl\u{a}cuței \^{i}n aproape toate cazurile reale testate. Av\^{a}nd \^{i}n vedere evoluția și popularitatea inteligenței artificiale, am decis s\u{a} adaug și o metod\u{a} prin care detectarea pl\u{a}cuței s\u{a} se realizeze folosind o rețea neural\u{a} convoluțional\u{a}, l\u{a}s\^{a}nd la alegerea utilizatorului metoda dorit\u{a} a fi folosit\u{a} \^{i}n cadrul sistemului de monitorizare și gestionare al parc\u{a}rii auto. Mai departe, pe imaginea decupat\u{a} ce conține doar pl\u{a}cuța de \^{i}nmatriculare, se efectueaz\u{a} din nou o preprocesare ce const\u{a} \^{i}n egalizarea adaptiv\u{a} a histogramei și corectarea distorsiunilor geometrice, dac\u{a} este cazul, urm\^{a}nd aplicarea algoritmului de template matching pe fiecare caracter \^{i}n parte pentru recunoșterea final\u{a} a text-ului de pe pl\u{a}cuț\u{a}.

\^{I}n continuare, urm\u{a}torul pas a constat \^{i}n realizarea interfeței grafice din cadrul aplicației, gestionarea camerelor video ce se ocup\u{a} de detectarea și recunoașterea numerelor de \^{i}nmatriculare și conectarea la baza de date și manipularea și accesarea \^{i}nregistr\u{a}rilor din cadrul acesteia. Interfața a fost proiectat\u{a} astfel \^{i}nc\^{a}t s\u{a} fie ușor de utilizat, av\^{a}nd denumiri clare ale acțiunilor ce urmeaz\u{a} a fi efectuate. Simplitatea interfeței grafice, aceasta av\^{a}nd un num\u{a}r mic de butoane și meniuri, este util\u{a}, sistemul de monitorizare și gestionare a parc\u{a}rii fiind configurat cu ușurinț\u{a} indiferent dac\u{a} utilizatorul acestuia a citit sau nu instrucțiunile de utilizare. De asemenea, configurarea acestuia const\u{a} \^{i}n simpla ad\u{a}ugare a unor camere video ce vor fi de un anumit tip, intrare, ieșire sau parcare, iar cu ajutorul acestora, toate evenimentele (intr\u{a}ri, ieșiri, parc\u{a}ri) din parcare sunt \^{i}nregistrate \^{i}ntr-o baz\u{a} de date și sunt folosite \^{i}n cea de a dou\u{a} aplicație, ce const\u{a} \^{i}ntr-un site web, unde utilizatorii vor putea vedea toate detaliile necesare legate de parcare.

\^{I}n final, ultimul pas a fost dezvoltarea aplicației web unde utilizatorii s\u{a}-și poat\u{a} vizualiza toate detaliile legate de sesiunile lor din parcare. Aceștia pot vizualiza detalii precum, data și ora \^{i}nceperii sau \^{i}ncheierii unei sesiuni, locurile pe care a parcat \^{i}n cadrul unei sesiuni dorite și timpul petrecut. Pe l\^{a}ng\u{a} asta, \^{i}n cazul \^{i}nt\^{a}mpin\u{a}rii unor dificult\u{a}ți, aceștia vor putea adresa \^{i}ntreb\u{a}ri pe un mini-chat la care vor putea primi r\u{a}spuns fie de la un administrator, fie de la un alt utilizator (șofer), sau chiar \^{i}ntocmirea unei sesiz\u{a}ri \^{i}n cazul unei dificult\u{a}ți mai grave.

\subsection{Dezvolt\u{a}ri ulterioare}

Exist\u{a} mai multe direcții ce prezint\u{a} potențial at\^{a}t \^{i}n \^{i}mbun\u{a}t\u{a}țirea rezultatelor detecției și recu-noașterii numerelor de \^{i}nmatriculare, c\^{a}t și \^{i}n \^{i}mbun\u{a}t\u{a}țirea aplicației web, oferind mult mai multe funcționalit\u{a}ți ce ar putea veni \^{i}n sprijinul șoferilor.

\begin{itemize}
    \item G\u{a}sirea unei metode alternative pentru detectarea locurilor de parcare - \^{I}n cadrul aplicației principale, s\u{a} se g\u{a}seasc\u{a} o metod\u{a} mai eficient\u{a} pentru detectarea locurilor de parcare pe care un șofer a parcat.
    \item Crearea unui sistem de pl\u{a}ți - \^{I}n cadrul aplicației web s-ar putea ad\u{a}uga un sistem de pl\u{a}ți prin care un șofer va trebui s\u{a} pl\u{a}teasc\u{a} o sum\u{a} \^{i}n funcție de timpul petrecut \^{i}n parcare și doar dup\u{a} efectuarea pl\u{a}ții s\u{a} poat\u{a} p\u{a}r\u{a}si parcarea.
    \item Rețele neurale pentru recunoașterea caracterelor - Antrenarea și folosirea unei rețele neurale pentru recunoașterea caracterelor din pl\u{a}cuțele de \^{i}nmatriculare.
    \item Extinderea setului de date pentru template matching - Un set de date ce conține imagini a tuturor caracterelor \^{i}n majoritatea unghiurilor posibile ar putea duce la o acuratețe mai mare \^{i}n recunoașterea caracterelor.
    \item Posibilitatea recomand\u{a}rii unui loc de parcare - La intrarea \^{i}n parcare, șoferul s\u{a} poat\u{a} primi ca recomandare un loc de parcare avantajos, l\^{a}ng\u{a} care s\u{a} nu existe alte mașini, dac\u{a} este posibil.
    \item Posibilitatea achizițion\u{a}rii de abonamente - Șoferii ar putea avea posibilitatea achizițion\u{a}rii unui abonament. De exemplu, dac\u{a} ora \^{i}n parcare ar costa 2 RON și șoferii vor fi taxați non-stop, s-ar putea ad\u{a}uga un abonament de o zi care ar putea costa 16 RON și ar fi disponibil pentru 24 ore de la data cump\u{a}r\u{a}rii abonamentului. Dup\u{a} expirarea celor 24 ore, șoferul va fi taxat din nou cu 2 RON pe or\u{a}.
    \item Dezvoltarea unei aplicații mobile - Pe l\^{a}ng\u{a} aplicația web, s-ar putea dezvolta o aplicație mobile cu aceleași funcționalit\u{a}ți ca \^{i}n prezent, plus trimiterea de notific\u{a}ri privind timpul petrecut/r\u{a}mas \^{i}n parcare, expirarea abonamentelor, eventuale anunțuri și chiar realizarea pl\u{a}ților prin intermediul acesteia.
\end{itemize}
%țș

\begin{thebibliography}{9}

\bibitem{cppref}
Albatross, cplusplus.com, n.d.. \url{https://cplusplus.com/info/description/} [Accessed: 11.02.2024]

\bibitem{javaref}
Desiree D. Martinez, Axl Heart P. Remegio, Darllaine Lincopinis. 
"A Review on Java Programming Language." May 2023. \url{https://www.researchgate.net/publication/371166744\_A\_Review\_on\_Java\_Programming\_Language}. [Accessed: 11.02.2024].

\bibitem{sqlref}
"SQL", Wikipedia, 2024, \url{https://en.wikipedia.org/wiki/SQL}.[Accessed: 20.02.2024]

\bibitem{cnn}
Asifullah Khan, Anabia Sohail, Umme Zahoora, and Aqsa Saeed. "A survey of the recent architectures of deep convolutional neural networks.", December 2020.

\bibitem{opencv}
OpenCV, n.d.. \url{https://opencv.org/} [Accessed: 26.03.2024]

\bibitem{qt}
"About Qt," Qt, \url{https://wiki.qt.io/About\_Qt}. [Accessed 20.03.2024].

\bibitem{qtdesigner}
"Qt Designer Manual," Qt, n.d.. \url{https://doc.qt.io/qt-5/qtdesigner-manual.html}. [Accessed 20.03.2024].

\bibitem{yolo}
"Comprehensive Guide to Ultralytics YOLOv5", Ultralytics, n.d.. \url{https://docs.ultralytics.com/yolov5}/ [Accessed: 14.03.2024].

\bibitem{spring}
"Spring Framework", Spring, n.d.. \url{https://spring.io/projects/spring-framework} [Accessed: 30.04.2024].

\bibitem{cmake}
"About CMake," CMake, n.d.. \url{https://cmake.org/overview/}. [Accessed 20.03.2024].

\bibitem{grayscale}
T. Helland, "Seven grayscale conversion algorithms," tannerhelland.com, 01.10.2011. \url{https://tannerhelland.com/2011/10/01/grayscale-image-algorithm-vb6.html}. [Accessed 17.02.2024].

\bibitem{filtering}
Owotogbe Segun Joshua, Sunday Ibiyemi and B. A. Adu, "A Comprehensive Review On Various Types of Noise in Image Processing", November 2019. \url{https://www.researchgate.net/publication/338112901\_A\_Comprehensive\_Review\_On\_Various-\_Types\_of\_Noise\_in\_Image\_Processing}. [Accessed: 20.02.2024].

\bibitem{grayscaleopening}
Kaehler, A., Bradski, G., Learning OpenCV 3: computer vision in C++ with the OpenCV library, O'Reilly Media, Editura Inc., 2016.

\bibitem{segmentation}
"Otsu's method", Wikipedia, 2024. \url{https://en.wikipedia.org/wiki/Otsu\%27s\_method}. [Accessed: 04.04.2024].

\bibitem{otsu}
E. Hodneland, "Segmentation of Digital Images," pp. 17-18, 22th of July 2003. 

\bibitem{connectedcomp}
Connected Components Labeling, n.d.. \url{https://homepages.inf.ed.ac.uk/rbf/HIPR2/label.htm} [Accessed: 04.04.2024].

\bibitem{green}
"Green's theorem", Wikipedia, 2024, \url{https://en.wikipedia.org/wiki/Green\%27s\_theorem}. [Accessed: 20.05.2024]

\bibitem{roboflowuniverse}
Roboflow Universe, n.d.. \url{https://universe.roboflow.com/} [Acessed: 10.04.2024]

\bibitem{inference}
"Object Detection using YOLOv5 OpenCV DNN in C++ and Python", LearnOpenCV, April 2022, \url{https://learnopencv.com/object-detection-using-yolov5-and-opencv-dnn-in-c-and-python/} [Accessed: 15.04.2024]

\bibitem{clahe}
"Image Contrast Enhancement Using CLAHE", Analytics Vidhya, July 2024, \url{https://www.analyticsvidhya.com/blog/2022/08/image-contrast-enhancement-using-clahe/} [Accessed: 25.04.2024].

\bibitem{histogram}
"Image histogram", Scientific Volume Imaging, n.d.. \url{https://svi.nl/ImageHistogram} [Accessed: 20.04.2024].

\bibitem{geometricdistortion}
Qiang Wu, Fatima A. Merchant, and Kenneth R. Castleman, "Microscope Image Processing", pp. 47-54, 2022.

\bibitem{undistortion}
Kim, T.-G., Yun, B.-J., Kim T.-H., Lee, J.-Y., Park, K.-H., Jeong, Y., Kim, H.D., "Recognition of Vehicle License Plates Based on Image Processing", 7th of July 2021, \url{https://www.mdpi.com/2076-3417/11/14/6292} [Accessed: 27.05.2024].

\bibitem{templatematching}
"Template Matching", OpenCV, n.d.. \url{https://docs.opencv.org/4.x/d4/dc6/tutorial\_py\_template\_matching.html} [Accessed: 24.05.2024].

\bibitem{templatematchingart}
Nadira Muda, Nik Kamariah Nik Ismail, Siti Azami Abu Bakar, Jasni Mohamad Zain, "Optical Character Recognition By Using Template Matching (Alphabet)" \url{https://core.ac.uk/download/pdf/159177553.pdf} [Accessed: 24.05.2024]

\bibitem{mvc}
"Model-View-Controller Design Pattern", GeeksForGeeks, 19th of February 2024. \url{https://www.geeksforgeeks.org/mvc-design-pattern/} [Accessed: 20.05.2024].

\bibitem{threelayer}
Alain Sondrae, "Three-Layered Architecture (With Example)", 22nd of October 2022. \url{https://medium.com/@asoldan1459/three-layered-architecture-with-example-b597a2161538} [Accessed: 20.03.2024].

\bibitem{widgets}
"Widgets and Layouts," Qt, n.d.. \url{https://wiki.qt.io/Widgets\_and\_Layouts/ro}. [Accessed: 20.03.2024].

\end{thebibliography}

\end{document}